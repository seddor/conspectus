# HTTP

## HTTP 1.0

HTTP – текстовый протокол, с помощью которого взаимодействуют клиент, например, браузер и сервер.

Работает таким образом: пользователь шлёт определённый запрос на сервер, запрашивая или передавая нужные данные, а сервер, на основе запроса, выпонляет нужную логику и возвращает результат. Результат обычно представляет из себя HTTL-страницу, либо редирект.

HTTP — протокол прикладного уровня. Он предназначен для общения между двумя программами (клиент и сервер). Сам по себе HTTP не может соедининять устройства, для этого используются другие протоколы, например TCP.

### Запрос

Запрос состоит из нескольких частей, первая часть _стартовая строка (request line)_, вторая — заголовки.

В стартовой строке указываются:

* Глагол/метод, он определяет как клиенту стоит интерпретировать запрос, список всех методов можно посмотреть [здесь](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods). Часто используемые: GET и POST;
* Путь к ресрусу, если указан `/` — то обращение к корню сайта.
* Версия протокола, напрммер `HTTP/1.0`, `HTTP/1.1`.

Далее, с новой строки, идут заголовки. Они позволяют передавать дополнительную информацию. Заголовок передаются в следующем виде `name: value`. Заголовоки разделяются между собой переводами строк.

```
HEAD/HTTP/1.0
User-Agent:googlechrome
```

Здесь:

* HEAD — метод
* / (первая) — путь
* HTTP/1.0 — версия
* User-Agent:googlechrome — заголовок

Затем опционально идтёт тело запроса.

### Ответ

```
HTTP/1.0 200 OK
Date: Sat, 18 Jan 2020 09:24:50 GMT
Expires: -1
Cache-Control: private, max-age=0
```

Состоит из status line (`HTTP/1.0 200 OK`), здесь указана версия протокола и статус ответа (`200 OK`). В HTTP определено множество [кодов ответа](https://developer.mozilla.org/ru/docs/Web/HTTP/Status) отражающего разные состояния.

Далее идут заголовки, по структуре аналогичные заголовкам запроса.

Затем опционально идтёт тело ответа.

После получение ответа HTTP 1.0 закрывает соединение.

## HTTP 1.1

HTTP 1.1 расширяет функционал прошлой версии и добавляет виртуальные хосты.

К запросу прошлой версии добавляет новая часть:

```
host: example.com
```

Он определяет какой именно хост должен быть возвращён с запрошенного IP адреса.

После получения ответа HTTP 1.1 **не** закрывает соединение.  HTTP 1.1 вводит понятие *keep-alive*, которое обозначает, что TCP, по которому уходит HTTP, не закрывается. Соединение не будет закрыто до того как не произойдёт таймаут либо оно не будет явно разорвано.

Для того чтобы принудительно закрыть соединения при запросе нужно указать заголовок: `connection: close`.

## Тело HTTP-запроса

Запросы и ответы могут содержать в себе тело.

Тело ответа идёт после заголовков и отдеяются пустой строкой, для определения конца тела используется специальный заголовок, который формируется сервером — `Content-Length: <size>` размер указывается в байтах.

Для тел запроса действуют такие же правила.

Как правило, помимо размера, требуется также передать тип данных в теле, это делается с помощью заголовка `Content-Type: <type>`

## Отправка форм

Обычно для форм используется тип *application/x-www-form-urlencoded*, он представляет из себя формат:

```
key1=value1&key2=value2
```

Данные передаваемые в формах кодируются, чтобы не было конфликтов.

### Другие способы кодирования

Помимо обычного кодирования через `ключ=значение` существуют и другие форматы, самым распостранённым из них является JSON. У него множество преимуществ:

* Представляет из себя строку, что необходимо для HTTP;
* Не звисит от языка;
* Позволяет описывать сложные структуры;
* Человекочитаем.

На данный момент он считается стандартом для обмена информацией между сервисами в интернете. Для отправки данных в этом формате используется заголовок *Content-Type: application/json*.

## Transfer-Encoding

Иногда объём передаваемых данных может быть достаточно большим, при этом может быть не известен конечный размер данных, например при загрузке архива или трансляции.

Для решения этой проблемы существует специальный механизм передачи небольшими частями — чанками (chunks), для этого механизма используется заголовок *Transfer-Encoding* со значением *chunked*.

В стандартном ответе его тело можно обрабатывать только целиком, после его полного получения. При работе с чанками можно обрабатывать ответ до получения полного тела ответа.

Сами чанки выглядят так:

```
400 # длина чанка
Какие-то данные первого чанка
400
Данные второго чанка
400
и так далее
0 # последний чанк нулевой длины


```

В начале каждого чанка указывается его размер, затем данные, после этого делается перевод строки и после этого идёт следующий чанк. Таким образом можно передать сколько угодно чанков, время ограничено только таймаутами внутри сервера.

Для завершения передачи передаётся последний банк нулевой длины. После этого делается два перевода строки и запрос считается завершённным.

### Формат сообщений

Для отделения записей размеров блоков (частей) от их содержания  используется разделитель CRLF (как строка: «\r\n»; как байты в формате  HEX: 0x0D, 0x0A). Длина блока — это размер содержания блока, разделители CRLF не учитываются.

Схематическое представление: `<длина блока в HEX><CRLF><содержание блока><CRLF>`

Последний блок строится по той же схеме, потому имеет следующий вид по причине отсутствия содержания: `0<CRLF><CRLF>`

[Стандарт](https://datatracker.ietf.org/doc/html/rfc2616#section-3.7.1) также позволяет использовать в качестве разделителя только CR или только LF.

## Передача данных через query string

Помимо данных передаваемых в теле запроса можно также передавать строку запроса (query string). Это параметры `ключ=значение`, котрые распологаются в _request line_ после указания глагола в пути:

```
GET /?key=value HTTP/1.1
```

В начале query string ставится `?` затем идут пары `ключ=значение`, разделённые `&`.

## Перенаправление

Перенаправление (редиректы) — ответ, который подразумевает, что после него нужно перейти по указаному адресу, он выглядит следующим образом:

```
telnet hexlet.io 80
GET / HTTP/1.1
host: hexlet.io

HTTP/1.1 301 Moved Permanently
Date: Thu, 14 May 2020 15:00:05 GMT
Transfer-Encoding: chunked
Connection: keep-alive
Cache-Control: max-age=3600
Expires: Thu, 14 May 2020 16:00:05 GMT
Location: https://hexlet.io/
Server: cloudflare
CF-RAY: 59357c73fadaf2a0-WAW
cf-request-id: 02b54c363b0000f2a07c8f0200000001

0
```

Работает это так:

* Возвратащается специальный код ответа: 300, существуют разные типы редиректов, кадый имеет свой код ответа:
  * 301 — ресурс перемещён на всегда, этот редирект можно закешировать
  * 302 — временный перенос
* Заголовок _Location_ — указывает куда нужно перейти

## Базовая аутентификация

В HTTP  имеется встроенный мехнизм аутентификации. Работает он следующим образом.

При заходе на конкретную страницу/сайт, которые требуют аутентификацию браузер отобразит форму аутентификации (встроенную в браузер).

При вводе неверных данных (в этом случае бразер обычно запросит данные заново) или нажатии на `cancel ` будет получена ошибка 401, означающая что ресурс не доступен без аутентифакации.

В итоге бразуер просто рисует эту форму при получении ответа с кодом 401, пока не будет отослан корректный заголовок с данными аутентификации.

Для авторизации используется заголовок _Authorization_:

```
Authorization: Basic aHR0cHdhdGNoDmY=
```

В его значении содержится указание на тип авторизации `Basic` и зашифрованные в base64 данные для авторизации.

## Cookies

Куки (cookies) — используются для сохранение состояния в HTTP.

Для установки куки используется заголовок *set-cookie*:

```
set-cookie: _hexlet_session2=AiUPd6RFbcrnoGnZSLAYSBzdJqxsQ4sTc%2BW0xXuOKzlenyv5GwkkbpdkD6IVDybDlD8vQcOcgGax98%2FmzIBJrz9f%2BDIJxWRpknZsRSfBXuC9yRfndovBUG6w4fTql4qp7zPozd2veFDLOU4koPVYiUQxgBLM6NkyYg%2Bhs%2BQe%2FSZezleVgMBVD%2FFC070DjV7t2eN01o26kcbd0pQsf9k1LE4JN0aDzSxu8elxLyAWkIJ5l3m%2BcI%2BpgOxk87Uwh9WdTHVuDaraiRaVJz1aZq5hr%2FgzaZiK%2Bgi6ChX60nhha1an610b1v3EE7xgkEM332uFPU0w675fHEr4APTdPDVtJRa3--qQi0cqcljC8i4klD--fXTErw9bhX7%2Fd1xfPE4Gww%3D%3D; domain=.hexlet.io; path=/; expires=Sun, 16 Aug 2020 03:38:11 GMT; secure; HttpOnly; SameSite=Lax
set-cookie: GCLB=CLTE8bzdlaS6Zg; path=/; HttpOnly; expires=Thu, 16-Jul-2020 03:39:50 GMT
```

* Каждая куки посылается в отдельном заголовке;
* Кука представляет из себя пару `ключ=значение` о отделяется от дополнительных параметров точкой запятой;
* Куки сохраняются в браузере на клиенте и при следующих запросах он отправляет их обратно на сервер, в самом бразуере куки никак не используются.

### Типы

Куки можно разделить как минимум на два типа:

#### Сессионные куки

Такая кука удаляется при закрытии браузера.

#### Постоянные куки

Такая кука имеет определённое время жизни, которое указывается в параметре *expires*:

```
expires=Thu, 16-Jul-2020 03:39:50 GMT;
```

В значении указывается дата удаление куки, после которой она перестанет отсылаться не сервер.

Аналогичный параметр *MAX-AGE*:

```
MAX-AGE=2592000;
```

В нём указывается количество секунд, по истечению которых куа будет удалена.

### Параметры domain и path

Параметры *domain* и *path* задают **область видимости куки** — это URL, на которые кука может отправляться. Если они не заданы, то  по умолчанию кука будет пересылаться на сервер только для текущего пути и домена.

```
domain=.hexlet.io; path=/;
```

В этом примере кука будет работать для домена hexlet.io и всех его поддонов, путь куки корневой — т.е. кука передаётся для всех путей.

Если не устанавливать домен, то куку будет работать только для домена hexlet.io.

Уникальность куки определяется тремя параметрами *key* (имя куки), *domain* и *path*. Это значит, что если какую-то куку нужно переустановить, то при следующем запросе в *set-cookie* эти параметры должны совпадать. Если хотя бы один из них отличается, то будет установлена новая кука.

### Удаление куки

Отдельного заголовка для удаление куки не предусмотренно, для их удаление нужно установить нулевой или отрицательный параметр *MAX-AGE*, либо задать *expires* со значением в прошлом.

### HttpOnly cookie

Дополнительный параметр *HttpOnly* означает, что куку нельзя использовать в JavaScript на странице сайта. Этот параметр используется для допольнительной защиты от XSS-атак.

### Отправка на сервер

Отправление кук на сервер происходит через заголовок _Cookie_:

```
Cookie: GCLB=CLiC7uWajOOrzAE;_hexlet_session2=gu3n8MCidqZ28VfjpzJuF74d4ohla6uYq9Q%2B2XBcalsa3VUCzURBWTXvscuzSI%2BF3lnHAN%2FUt6IJnXgkH%2B6jDKgyStVb8W%2BLHwIbypoxajN3fB5ksFT3Qu28RvDQpL6hBmqq7V2eFdfLMGtkmtcpfAUYNGffwaBAlQyQKnvhkCpEf5IIWkwWfe9Nt8dG3lIueeir9fGxZP7Fpcw9IP9HfgSansgXugtFI1rw06UhgrrK%2BEnaf4EmIgVdH6KYpDBKXpUUXz8vFRvkOMX5j%2BZNMTu%2BKDBzmGlFjcm1mCZl4ozZWDCocFO4CTW7z9LmzKYbcEGkUEhRbOu%2BTvLgVo80LilK--x3y6jxx%2FjYcLp5tr--9nrQ0XmAhtGAuIFvMYvWig%3D%3D
```

Все куки отправляются в одном заголвоке в формате `key=value` разделённые `;`, без дополнительных параметров.
