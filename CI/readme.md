# CI

Непрерываная интеграция (CI) — практика разработки, которая заключается в частой атоматизированной сборе приложения для быстрого выявления проблем. Обычно интеграция выполняется на коммиты в репозитории. За этим следит либо специальный сервер, либо сервис CI. Он згаружает код, собирает его и запускает различные проверки.

Что и как запускать опредялется программистом. В первую очередь запускаются тесты и лифтеры, кроме них могут запускаться утилиты для анализа безопасности, актуализации зависимостей и т.п.

На каждый коммит запускается сборка, если какие-то проверки во время сборки не прошли, то разработчик разбирается с проблемами и устроняет их.

Для внедрения непрерывной интеграции либо делают сервер c Jenkins (или аналогом), тут нужно много ручной работы, либо используют специальные сервисы непрерывной ингтерации.

## GitHub Actions

GitHub Actions — бесплатная для публичных репозиториев система непрерывной интеграции.

GitHub Actions позволяет делать:

- Запустить проверку кода линтером и тестами;
- Выполнить деплой проекта;
- Опубликовать новую версию пакета;
- Подключить оповещения в мессенджер о событиях в репозитории (новые issue, PR);
- и многое другое.

Принцип работы с GitHub Actions: в репозитории создаётся директори _.github/workflows_. Внутри неё размещаются файлы с описанием шагов, которые нужно выполнить на различные действия.

Пример процесса "hello-world", который запускается на пуш в репозиторий:

```yaml
# file: .github/workflows/hello-world.yml
name: hello-world
# on – определяет события, которые запускают воркфлоу
on: push
jobs:
  # build – произвольно выбранное имя задания
  # их может быть больше одного
  build:
    # операционная система для работы воркфлоу
    runs-on: ubuntu-latest
    steps: # список шагов, которые надо выполнить
      # экшен, выполняет какую-то задачу
      # checkout – клонирует репозиторий
      - uses: actions/checkout@v3
      # run – произвольная bash-команда
      # ls -la выведет содержимое текущего репозитория
      - run: ls -la
```

### Основные понятия

* Воркфлоу / Workflows — Каждый репорзиторий может содержать один или несколько воркфлоу, каждый из них определяется в отдельном файле конфигурации в каталоге репозитория _.github/workflows_. Воркфлоу могут выполняться параллельно;
* События / Events — Воркфлоу может запускаться одним или несколькими событиями. Это могут быть внутрение события GitHub (пуш, релиз, пул-реквест и т.д.), запланированные события (запуск по cron) или произвольные внешние события (запускаются через Webhook API GitHub);
* Задания / Jobs — воркфлоу состоит из одного или нескольких заданий. Задание содержит набор команд, которые запускаются вместе с рабочим процессом. По умолчанию при врокфлоу все его задания выполняются параллельно, однако между ними можно определить зависимость, что они выполнялись последовательно;
* Раннеры / Runners — каждое задание выполняется на определённом раннер – временном окружении GitHub с выбораной ОС. Также существуют [автономные раннеры](https://docs.github.com/en/actions/hosting-your-own-runners), которые позволяют создавать своё окружение для выполнение экшена;
* Шаги / Steps — задания состоят из последовательности шагов. Шаг — это либо команда оболочки (Shell command), либо экшен (action). Все шаги задания выполняются последовательно на ранение, связанном с заданием. По умолчанию в случае собя шага все следующие шаги задания пропускаются;
* Экшен / Actions — многократно используемый блок кода, который может служить шагом задания. Каждый экшен может принимать на вход параметры и создавать любые значения, которые затем можно использовать в других экшена. Разработчики могут создавать собственные или использовать опубликованные сообществом. Все общие экшены доступны [GitHub Marketplace](https://github.com/marketplace?type=actions).

[Документация GitHub Actions](https://docs.github.com/en/actions/quickstart)

### Задания (Jobs)

Задания в воркфлоу обозначают какую-то часть процесса интеграции, например, сборку, тестирование, деплой и т.п. По умолчанию задания запускаются параллельно, но если нужно их можно упорядочить:

```yaml
# сборка фронтенда и бекенда происходит одновременно
# а тесты бекенда запускаются только после сборки бекенда
jobs:
  build-frontend:
  build-backend:
  test:
    needs: build-backend
```

Здесь `test` запуститься только после успешного завершения `build-backend`.

Иногда задания нужно выполнять независимо, от результатов предыдущих задний, для этого используется `if`:

```yaml
jobs:
  build-frontend:
  build-backend:
  test:
    # конструкция внутри ${{}} называется выражением
    if: ${{ always() }}
    needs: build-backend
```

Для обеспечения паралелльности GitHub запускает задания в независимых директориях. Поэтому файлы, которые создает конкретное задание не видно из других заданий. Если нужно чтобы файлы из одного задачния были видно в другом нужно дополнительно [включить шаги](https://docs.github.com/en/actions/learn-github-actions/essential-features-of-github-actions#sharing-data-between-jobs) по переносу данных.

Поэтому для проектов с простой структурой достаточно создать одного задание, которое делает всё что нужно:

```yaml
# Пример для проекта на Node.js
jobs:
  build: # имя взято для примера
    runs-on: ubuntu-latest

    steps:
      # Клонируем репозиторий
      - uses: actions/checkout@v3
      # Устанавливаем Node.js
      - uses: actions/setup-node@v1
      # Ставим зависимости
      - run: npm install
      # Запускаем линтер
      - run: npm run lint
      # Запускаем тесты
      # у шагов может быть имя, иногда это помогает отладке
      # имя выводится на Github при просмотре сборки
      - name: run tests
        run: npm test # name и run относятся к одной задаче, поэтому дефис ставится только перед name
```

Каждый шаг задания запускается в одной и той же директории. Туда же клонируется репозиторий экшеном *checkout*.

#### Операционная система

Github Actions позволяет выбрать одну из трех операционных систем: Ubuntu, Windows и MacOS. Все возможные варианты можно посмотреть [здесь](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources). Обычно используют `ubuntu-latest`.

Если нужно запускать для нескольких ОС то можно сделать так:

```yaml
jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    steps:
      # тут шаги
```

#### Переменные окружения

С помощью ключа `env` задаются переменнные окружения, доступные для всех шагов текущего задания:

```yaml
jobs:
  run:
    env:
      RAILS_ENV: staging
      DEBUG: 1
```

Множество переменных окружения [определяется автоматически](https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables), их можно использовать:

```yaml
steps:
  - run: echo "Имя текущего воркфлоу – $GITHUB_WORKFLOW"
```

Также переменные можно определять и переопределять в конкретных шагах:

```yaml
steps:
  - run: echo "$key"
    env:
      # Если такой ключ определен на уровне задания,
      # то он будет переопределен текущим значением
      key: value
```

[Запуск сервисов](https://docs.github.com/en/actions/using-containerized-services/about-service-containers)

### Экшены (Actions)

Экшены позволяют значительно сократить количество кода в воркфлоу, и ускорить процесс сборки.

Чаще вссего в сборках используется экшен `checkout`, клонирующий репозиторий в рабочую директорию:

```yaml
steps:
  - uses: actions/checkout@v3
```

Экшен работает как один из шагов задания.

Имя экшаена состоит из _имя пользователя или команды/название репозитория_. Встроенные экшены находятся в команде _actions_.

Помимо имени нужно указать версию, за версиями нужно следить самостоятельно в репозитории соотвествующего экшена.

У экшена могут быть параметры, они задаются ключём `with`:

```yaml
steps:
  - uses: actions/checkout@v2
  # https://github.com/actions/setup-node
  - uses: actions/setup-node@v2
    with:
      node-version: '16.x'
      cache: 'npm' # ускоряет повторные сборки
  - run: npm ci
  - run: npm test
```