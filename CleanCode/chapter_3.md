# Функции

## Компактность

Функции должны быть кмпакнтными.

## Блоки и отступы

* Блоки в `if`, `else`, `while` и т.д. должны состоять из одной строки, в которой обычно содержится вызов функции;
* Функции не должны содержать вложенных структур;
* Маскимальный уровень отступов в функции не должен превышать одного-двух.

## Правило одной операции

Функция должна выполнять только одну операцию и делать это хорошо. Ничего другого она не должна.

## Один уровень абстракции на функцию

Команды функции должны находится на одной уровне абстракции, смешение уровней абстракции всегда создаёт путаницу.

## Чтение кода сверху вниз: правило понижения

Код должен читаться как расказ: сверху вниз. За кажой функцией должны следовать функции следующего уровня абстракции. Это позволяет читать код, последовательно спускаясь по уровням абстракции.

## Команды switch

Написать компактный switch довольно сложно, с ним также возникает проблемы что он нарущает правило единственной отвественности фнкцции. Чтобы это избежать нужно исползовать switch для создание полиморфных объектов и он скрывается за отношение наследования.

Например swith используется для создание экземпляров потомков класса, с соответствующими функциями для этого типа.

## Используйсте содержательные имена

* Важно использовать содержательные имена для функций, не стоит боятся длинных имён, если они прояняют суть функции лучше коротких.
* Будте полседовательны, используйте в именах те же словосачетния, глаголы, существительные, которые используются в остальных модулях

## Аргументы функций

Названия функций по количеству аргументов:

* 0 — нуль-арные (идельный вариант)
* 1 — унарные
* 2 — бинарные
* 3 — тернарные (следует избегать)
* >3 — полиарные (нужно очень весомые аргументы для использования таких функций)

Аргменты усложняют функцию и лишают их значительной концептуальной мощи.

Аргументы создают множество проблем для тестирования, т.к. нужно учитывать в тестах все возможные значения аргументов, а если их несколько то ещё и комбинации этих аргументов.

## Стандартные унарные формы

Существует два очень распостранёных случая вызова функции с одинм аргументом:

* Проверка некоторого условия, связанного с аргументом, например `isFileExists('filePath')`
* Обработка аргумента, его преобразование и возвращение

Важно выбирать имена, которые будут чётко отражать различия, и всегда использовать две формы в логически не противоречивых контекстах.

Менее распостранённый случай использования функций с одним аргуметом является _события_. В этой форме имеетется входной аргумент, а выходного аргумента нет. Предпологается, что программа интерпретирует вызов функции как событие и использует аргумент для изменения состояния системы. Например, `passwordAttemptFailedNtimes(int attemps)`. Читатель должен явно понимать, что перед ним событие.

Следует избегать унарных операций не относящихся к этим формам.

Преобразования, в которых вместо возвращаемого значения используется выходной аргумент сбивает с толку. Если функция преобразует свой входной аргумент, то рехультат должен передаватся в возвращаемом значении.

## Аргументы-флаги

Передача логического аргумента функции сильно усложняет метод, функция сразу начинает выполнять больше одной операции, для одного значения флага и для другого, что усложняет понимание функции.

## Бинарные функции

Функции с двумя аргументами понять сложнее, чем унарные функции. По возможности их стоит преобразовывать у унарные. Иногда бывают случаи, когда бинарные функции более логичны, например кода оба аргумента по сути являются часть одного целого, например `Point(0, 0)` — точка в дискретном пространстве. Вполне разумен с двумя аргументами, 

## Тернанарные функции

Разобраться в функциях с тремя аргементами значиительно сложнее, чем с бинарными. Их стоит всячески избегать и использовать только в крайних случаях.

## Объекты как аргументы

Если функция должна получать более двух, трёх и более элементов, то если возможно, стоит упаковать какие-то из них в отдельные классы, если эти аргументы можно соединить логически.

## Глаголы и ключевые слова

В унарных функциях название и аргумент должны образовывать естественную пару "глаолг-существительное", например `write(name)`.

## Избавтесь от побочных эффектов

Функция должна выполнять только то, что заложено в её имени. В ней не должно инциализироваться лишних элементов, изменяться свойств класса и т.п. если это не заложено в её имя.

## Выходные аргументы

Иногда входной аргумент может также являтся и выходым аргументом, например: `appendFooter(report)`, сразу непонятно, добавляет ли функци что-то к `report` или добавляет в какой-то другой объект используя `report`. Если нужно что-то добавить к входному параметры, то лучше таких вещей избегать и делать функции непосредственной часть класса: `report.appendFooter()`.

## Разделение команд и запросов

Функция должна что-то деалть или отвечать на какой-то вопрос, но не одновременно. Либо функция изменяет состояние объекта, либо возвращает информацию об этом объекте. Совмещение двух операций содаёт путаницу. 

Например, метод `set(field, value): bool`, меняет значение поле и возвращает true если всё ок и false, если такого поля нет. Такой метод пораждает конструкции вида `if (set('name', 'foo'))` из которой не понятно что имеет в виду, проверяется что условие присвоено? Что поле уже содержит значение? Непонятно. Поэтому стоит разделять эти операции и выделить их в разные методы:
```
if (has('name')) {
    set('name', 'foo')
}
```

## Используйте исключения вместо возвращения кодов ошибок

Использование кодов ошибок в качестве возвращаемого аргумента нарушает принцип разделения команд и запрсов и порождает множество условных ветвлечений, например нужно будет проверять успешный ли код пришол от метода и в зависимости от этого делать одно или другое. Лучше в случае ошибок сразу выбрасываь исключения и обрабатывать уже нужный сценарий в отдельно блоке try/catch.

## Изолируйсте блоки try/catch

Блоки try/catch запутывают стуктуру кода и смешивают обоработку ошибок с нормальной обработкой, поэтому тела блоков try и catch рекомендуется выделять в отдельные функции.

## Обработка ошибок как одна операция

Функции должны выполнять одну операцию, обработка ошибок — это одна операция. Отсюда следует, что если в функции присутвует try/catch то он должен начинать и заканчивать функцию ничего за их приделами в функции быть не должно.

## Не повторяйтесь

Стоит избегать дублирование кода, если один код повторяется в нескольких местах, то нужно попробовать вынести его отдельно.
