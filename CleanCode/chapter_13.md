# Многопоточность

## Зачем нужна многопоточность?

Многопоточное приложение может рассматриваться как стратегия устранения привязок. Оно помогает отделить выполняемую операцию от момента её выполнения. Их архитектура упрощает понимание системы и предоставляет мощные средства для разделения ответственности. Помиомо этого с помощью многопоточности можно увеличить производительность при работает с данными.

## Мифы и неверные представления

### Многопоточность всегда повышает быстродействие

Многопоточные приложения иногда повышают производительность, но только при относительно большом времени ожидания, которое могло бы эффективно использоваться другими потоками или процесорами.

### Написание многопоточного кода не изменяет архитектуру программы

На самом деле архитектура многопоточного алгоритма может значительно отличаться от архитектуры однопоточной системы. Отделение "что" и "когда" обычно оказывает огромное влияние на структуры системы.

### При работе с контейнерами (веб-контейнер, EJB) разбираться в проблемах многопоточного программирования не обязательно

В действительности желательно знать как работает контейнер и как защищаться от проблем одновременного обновления и взаимных блокировок.

### Объективные утверждения

* Многопоточность сопряжена с определёнными дополнительными затратами — в отношении как производительности, так и написания дополнительного кода;
* Правильная реализация многопоточности сложна даже для простых задач;
* Ошибка в многопоточном коде обычно не воспроизводятся, поэтому они часто игнорируются как случайные отклонения;
* Многопоточность часто требует фудноментальных изменений в стратегии проектирования.

## Защита от ошибок многопоточности

### Принцип единой ответствнности

Принцип единой ответственности (SRP) гласит, что метод/класс/компонент должен иметь одну причину для изменения. Многопоточные архитектуры достаточно сложны чтобы их можно было рассматривать как причину изменения сами по себе, поэтому они должны отделяться от основного кода. К сожалению, подробности многопоточной реализации нередко встраивается в другой код. Однако разработчик должен учитывать ряд факторов:

* Код реализации многопоточности имеет собственный цикл разработки, модификации и настройки;
* При написании кода реализация многопоточности возникают специфичные сложности, принципиально отличающиеся от сложностей однопоточного кода;
* Количество потенциальных сбоев в неверно написанном многопоточном коде достаточно велико и без дополнительного бремени в виде окружающего кода приложения.

Рекомендация: отделяйте код, относящийся к многопоточности от остального.

#### Следствие: ограничивайте область видимости

Количество критических секций (в которых происходит обращение к общим ресурсам, объектам и т.п.) в коде должно быть сведено к минимуму.

Рекомендация: серьёзно относитесь к инкопсуляции данных, жестко ограничте доступ к общим данным.

#### Следствие: используйте копии данных

Для избегания использования общих данных множно использовать копии: Скопировать данные с общего объекта и ограничить доступ к копии (только чтение). Объекты копируются, результаты накапливаются в коппиях, затем объеденяются в одном потоке.

#### Следствие: потоки должны быть как можно боллее независимы

Нужно стараться писать многопоточный код так, чтобы каждый поток существовал в собственном замкнутом пространстве и не использовал данные совмествно с другими процессами.

Рекомендация: постарайтесь разбить данные на незвависимые подмножества, с которыми могут работать независимые потоке (возможно, на разных процессорах).

### Знайте модели выполнения

Связанные ресурсы — ресуры с фиксированным размером или количеством, существующие в многопоточной среде, например подключение к БД, буферы чтения/записи.
Взаимное исключение — в любой момент времени с общими данными или общими ресурсами может работать только один поток.
Зависание — работа одного или нескольких потоков приостанавливается на слишком долгое время (или навсегда). 
Взаимная блокировка (deadlock) — два и более потока бесконечно ожидают завершения друг друга. Каждый поток захватил ресурс, необходимый для продолжения работч другого потока, и ни один поток не может завершиться без получения захваченного другим потоком ресруса.
Обратная блокировка (livelock) — потоки не могут "разойтись" — каждый поток пытается выполнить свою работу, но обнаруживает, что другой поток стоит у него на пути. Потоки постоянно пытаюсться продолжить выполнение, но им это не удаётся в течение слишком долгого времени (или вообще не удаётся).

#### Модель "производители—потребители" (активная блокировка, producer-consumer)

Один или несколько потоков производителей создают задачния и помещают в буфер или очередью Один или несколько потоков-потребителей извлечкают задания из очереди и выполняют их. Очередь — связанный ресурс между производителями и потребителями. Это значит, что потребители дожидаются свободного места в очереди, а потребители дожидаются пояления заданий. Координация между производителями и потребителями основона на передаче сигналов. Производитель сигнлизирует о том, что очередь не пуста (после добавление в неё), потребитель о том, что она пуста (после выполнения задач из неё). Обе стороны должны быть готовы ожидать оповещения о возможности продолжения работы.

#### Модель "читатели-писатели" (reader-writers)

Если в системе имеется общий ресрус, который в основном слежит источником информации для потоков-читателей, но время от времени обновляется потоками-писателями, на первый план выходит проблема оперативного обновления. Если обновление будет происходить не достаточно часто, это может привести к зависанию и накоплению устаревших данных. С другой стороны, слишком частые обновления влияют на производительность. 

Проектировщик должен найти баланс между потребностями читателей и пиателей, чтобы обеспечить правильный режим работы. В одной из стратегий писатели дожидаются, пока в системене не будет ни одного читателя, и только после этого выполняют обновление. Однако, при постоянном потоке читателей такая стратегия приведёт к зависанию писателей. С другой стороны, при большом коичестве высокоприоритетных писателей пострадает производительность. Поиск баланса и предотвращения ошибок многопоточного обновлления — оновные проблемы это модели выполнения.

### Остерегайтесь зависимостей между синхронными методами

Рекомендация: избегайте использование нескольких методов одного совместно используемого объекта

Если это сделать не удаётся, то существуют решения:

* Блоикровка на стороне клиента — килент устанавливает блокировку объекты для сервера перед вызовом первого метода и следит за тем, чтобы блокировка распостранялась на код, вызывающий последний метод;
* Блоикировка на стороне сервера — на стороне сервера создаётся метод, который блокирует сервер, вызвает все методы, после чего снимает блокировку. Этот новый метод взывается клиентом;
* Адаптирующий сервер — в системе создаётся посредник, который реализует блокировку. Ситуация может расматриваться как пример блокировки на стороне сервера, к оторой исходный сервре не может быть изменен.

### Синхронизированные секции должны иметь минимальный размер

Блокировка обходится дорого, т.к. они создают задержки и увеличивают затраты ресурсов, следовательно код не должен быть перегружен сихнонизируемыми конструкциями. С другой стороны, ве критичные секции должны быть защищены. Следовательно, код должен содержать как можно меньше критических секций.

Рекомендация: синхронизированные секции в ваших программах должны иметь минимальные размеры.

### О тредности корректного завершения

Одна из основных проблем завершения — взаимная блокировка программных потоков, бесконечно долго ожидающих сигнала на продолжение работы.

Например, есть система с родительским потоком и дочерними, она родительский поток завершается после закрытия дочерних, но если дочерний поток попад1т во взаимную блокировку родительский будет ждать вечно и система не сможет корректно завершиться.

Рекомендация: начинайте думать о корректном завершении на ранней стадии разработки. На это может уйти больше времени, чем предпологалось. Проанализируйте существующие алгоритмы, потому что задача сложнее, чем кажется.

## Тестирование многопоточного кода

Рекомендация: пишите тесты, направленные на выявление существующих проблем. Часто выполняйте их для разных вариантов программных/системных конфигураций и уровней нагрузки. Если при выполнении теста происходит ошибка, обязательно найдите причину. Не игнорируйте ошибку только потому, что при следующем запуске тест был выполнен успешно.

### Рассматривайте непреодические сбои как признаки возможных проблем многопоточности;

В многопоточном коде сбои могут происходить там, где их обычно быть не должно. Ошибки могут проявляться редко и их воспроизвести бывает очень трудно.

Рекомендация: не игнорируйте системные ошибки, считая их случайными, разовыми сбоями.

### Начните с отладки основного кода, на связанного с многопоточностью;

Рекомендация: не пытайтесь олновременно отлавливать ошибки в обычном и многопоточном коде. Убедитесь в том, что ваш код работает за пределами многопоточной среды.

### Реализуйте логическую изоляцию конфигураций многопоточного кода;

Напишите вспомогательный код для поддержки многопточности, который может работать в разных конфигурациях:

* Один поток, несколько потоков, количество потоков изменяется по ходу выполнения;
* Многопоточный код взаимодействует с реальным кодом или тестовыми заполнителями;
* Код выполняется с тестовыми заполнителями, которые работают быстро, медленно, с переменной скоростью;
* Настройте тесты таким образом, чтобы они могли выполняться заданое количество раз.

Рекомендация: реализуйте свой многопоточный код так, чтобы он мог выполняться в разных конфигурациях.

### Обеспечьте логическую изоляцию конфигураций многопоточного кода

Реализуйте систему так, чтобы количество потоков можно было бы легко менять. Подумайте, нельзя ли разрешить его изменение во время работы системы. Рассмотрите возможность автоматической настройки в зависимости от текущей производительности и загрузки системы.

### Протестируйте программу с количеством потоков, превышающим количество процессоров;

При переключении контекста системы могут происходить всякие неожиданости. Чтобы форсировать переключение задач, выполняйте свои задачи с количеством потоков привышающим количество физическим процессоров или ядер. Чем чаще происходит переключение задач, тем больше вероятность выявление пропущенной критической секции или возникновения взаимной блокировки.

### Протестируйсте программу на разных платформах;

Протестируйте системы во всех средах, которые могут использоваться для развёртывания. В разних системах реализация многопоточности может различаться, из-за чего могут возникать проблемы.

Рекомендация: многопоточный код небоходимо протестировать на всех целевых платформах — часто начиная с ранней стадии.

### Применяйте инструментовкук кода для повышения вероятности сбоев.

Ошибки в многопоточном коде обычно хорошо скрыты, простые тесты могут их не выявлять либо ошибки могут повторяться с разной переодичностью.

Для повышения вероятности выявления таких ошибок нужно вносить в код изменения заставляющие выполняться многопоточный код разными путями, можно использовать функции для остановки, приотеризации потоков и т.п.

Существует два способа инструментовки кода:

* Ручная;
* Автоматическая.

#### Ручная инструментовка

В код вставляются вызовы методов `wait()`, `sleep()`, `yield()` и `priority()`. Они позволяют изменить путь выполнение кода и выявить ранее скрытые проблемы.

У этого метода есть недостатки:

* Разработчик должен каким-то образом найти подходящие места для вставки вызовов;
* Как узнать, где и какой именно вызов следует вставить?;
* Если вставленные вызовы остануться в окончательной версии кода, это приведёт к замедлению работы;
* Приходится действовать "наобум": вы либо находите скрытые дефеткы, либо не находите их.

Отладочные вызовы должны быть только на стадии тестирования, не в окончательной версии кода. Также понадобяться средства для простого переключения конфигурации между запусками, повыщающие вероятность обнаружения ошибок в общей кодовой базе.

#### Атоматизированная инструментовка

Взоможно автоматическая инструментовка с примименением таких инструментов как:

* Aspect-Orientied Framework
* GGLIB
* ASM

Рекомендация: используйте стратегию случайного выбора пути выполнения для выявления ошибок.
