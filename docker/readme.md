# Docker

Docker — программа, позволяющая запускать процессы в изолированном окружении на базе специально созданных образов.

**Docker — универсальный способ доставки приложений на машины  (локальный компьютер или удаленные сервера) и их запуска в изолированном окружении.**

## Запуск

Пример запуска контейнера:

```bash
# запуск контенера на основе образа nginx
docker run -it nginx bash
# docker run <имя образа> <команда> <параметры если есть>
docker run nginx cat /etc/nginx/nginx.conf
# Обратите внимание на то, что после имени образа не указана никакая команда
# Такой подход работает в случае если команда на запуск прописана в самом образе
docker run -p 8080:80 nginx
# Запуск терминала
docker run -it <image_name>
# Запуск примонтированным volumne
docker run -dp 3000:3000 --mount type=volume,src=<volume_name>,target=/etc/todos <image_name>
# Запуск с динамичным volume
docker run --mount type=bind,src="$(pwd)"/src,target=/app <image_name>
```

Опции:

* `i` — интерактивно;
* `t` — запуск сессии терминала;
* `d` — в фоне;
* `p <host:container>` перенаправление порта из контейнера к хосту.

[docker run](https://docs.docker.com/engine/reference/commandline/run/)

## Работа с образами

Registry — хранилище образов. Оно находиться [здесь](https://hub.docker.com/).

Список локальнх образом можно посмотреть так:

```bash
docker images
```

Для загрузки/обновления образра используется команда:

```bash
docker pull <image_name>
```

В именам образов ингода встречается префикс, это имя аккаунта под которым был загружен этот образ, большинство образов имеют этот префикс. Некоторые образы идут без префикса — это образы поддерживаемые самим Docker, их список можно посмотреть [здесь](https://github.com/docker-library/official-images/tree/master/library)

Удаляются образы командной:

```bash
dokcer rmi <image_name>
```

Если в dokcer присутвует хотя бы один контейнер, использующий этот образ, то Docker не даст его удалить, для его удлаения нужно использовать флаг `-f`.

* [Docker Documentation: docker images](https://docs.docker.com/engine/reference/commandline/images/)
* [Docker Documentation: docker pull](https://docs.docker.com/engine/reference/commandline/pull/)
* [Docker Documentation: docker rmi](https://docs.docker.com/engine/reference/commandline/rmi/)

## Управление контейнерами

Просмотр логов:

```bash
docker logs -f <container_id>
```

Информция о запущенных контейнерах:

```bash
docker ps
```

Опция `-a` для вывода всех конйтенйров (без неё выводятся только запущенные).

Расшифровка столбиков:

- CONTAINER_ID — идентификатор контейнера. Так же, как и в git, используется сокращенная запись хеша;
- IMAGE — имя образа, из которого был поднят контейнер. Если не указан тег, то подразумевается *latest*;
- COMMAND — команда, которая выполнилась на самом деле при старте контейнера;
- CREATED — время создания контейнера;
- STATUS — текущее состояние;
- PORTS — проброс портов;
- NAMES — алиас. Docker позволяет кроме идентификатора иметь имя. Так  гораздо проще обращаться с контейнером. Если при создании контейнера имя не указано, то Docker самостоятельно его придумывает. В выводе выше как раз такое имя у nginx.

Информация о потребляемых конейнерами ресурсах:

```bash
docker stats
```

Остановка контейнера:

```bash
docker kill <container_id>
```

## Сеть

Флаг `-p`, при запуске контейнера, описывает как и какой порт выставить наружу. Например запись `8080:80` расшифровывается как: пробросить порт _8080_ снаружи контейнера в контерйнер на порт _80_. Причём, по умолчанию, порт 8080 слушается на `0.0.0.0`, т.е. на все доступных интерфейсах, поэтому запущенный таким образом контейнер доступен не только на `localhost:8080`, но и снаружи, если нужен проброс только локально, то нужно указать такую опцию: `-p 127.0.0.1:8080:80`.

Docker позволяет пробрасывать неограниченное количество портов, для этого нужно нужно колиечество указать параметр `-p`:

```bash
docker run -p 80:80 -p 443:443 nginx
```

[Docker Documentation: Container networking](https://docs.docker.com/config/containers/container-networking/)

[Как настроить маппинг портов между хостом и Docker-контейнером](https://ru.hexlet.io/blog/posts/mapping-docker)

## Файловая система

Проброс файлов/директорий в контейнер осуществялется при помощи опции `-v`:

```bash
docker run -it -v $HOME/.bash_history:/root/.bash_history ubuntu bash
```

Любые изменения применяются как внутри, так и снаружи контейнера.

Количество пробрасываемых файлов/директорий может быть любым, для этого нужно указать опцию `-v` нужное количество раз.

При работе с Volumes важно знать:

* Путь до файла или директории должен быть абсолютным;
* Если внутренний путь (то, что после `:`) не существует, то Docker создаст необоходимые директории и файлы. Если существует то заменит существующие проброшенными.

[Docker Documentation: Volumes](https://docs.docker.com/storage/volumes/)

## Подготовка собственного образа

Docker создаёт образ на основе файла _Dockerfile_, в котором описываются необходимые команды:

```dockerfile
FROM node:18

WORKDIR /app

COPY package.json .
COPY package-lock.json .

RUN npm ci

COPY . .

ENV FASTIFY_ADDRESS 0.0.0.0

# Команда, которая запускается автоматически
# при старте контейнера
CMD ["npm", "start"]
```

Сборка образа выполняется командой:

```bash
docker build -t <image_name> .
```

Опция `-t` указывает, что мы присваиваем имя образу.

### Загрузка образа

Готовый образ можно загрузить на [Docker Hub](https://hub.docker.com/).

Для этого нужно

* Регистрация на [Docker Hub](https://hub.docker.com/);
* Подключить аккаунт через команду `docker login`;
* Создать репозиторий в [Личном кабинете](https://hub.docker.com/repository/create).

Для загрузки образа ему необходимо дать правильное имя. По соглашению, часть имени до `/` должна совпадать с именем пользователя на Dokcer hub:

```bash
docker build -t <user name>/<image name> .
```

Для загрзуки используется команда:

```bash
docker push <user name>/<image name>
```

### Теги

Теги у Docker-репозиториев изменяемые. Если изменить образ и запушить его с тем же тегом, то образ поменяется. Для тега `latest` — это ок, но для остальных версионных тегов – нет. За выполнением этого правила нужно следить самоятоятельно, если контейнер изменился, то нужно использовать новый версионный тег:

```
docker build -t <user name>/<image name>:<tag> .
docker push <user name>/<image name>:<tag>
```

### Команды Dockerfile

Dockerfile состоит из команд, формирующих ФС образа. Каждая последующая команда видит результат предыдущей.

#### FROM

```dockerfile
# По умолчанию тег latest
FROM ubuntu
# С явно указанным тегом
FROM node:18
```

Образ — это в первую очередь ФС, которая формируется на базе команд описанных в _Dockerfile_. Docker берёт первоначальную ФС и изменяет её в соотвествии с описанием.

Практрически все образы формируются на основе уже существующего образа, образы образуют дерево, в котором образы наследуют друг другу от базового образа [scratch](https://hub.docker.com/_/scratch).

Команда `FROM` задаёт образ, чья ФС берёться за основу. Все последующие команды уже работают с ней, поэтому команда `FROM`  всегда идёт первой.

#### WORKDIR

```dockerfile
WORKDIR /app
```

Команда `WORKDIR` задаёт рабчий каталог, относительно которого выполняются все действия во время формирования образа и при входе в контейнер.

`WORKDIR` автоматически создает директорию, если ее еще нет.

#### COPY

```dockerfile
# файлы

COPY package.json .
# Аналогично
# COPY package.json package.json

COPY package-lock.json .

# Копирование всех файлов внутрь
COPY . .
```

Команда `COPY` копирует файлы и директории с хост-машины внутрь Docker-образа. Она принимает два параметра: первый — что котируется, второй — коду и под каким именем. Второй параметр может иметь такие значения:

- Абсолютный путь, копирование происходит ровно по нему;
- Относительный путь, копирование происходит относительно установленной рабочей директории `WORKDIR`;
- Точка, файл или директория копируется как есть в рабочую директорию;

Если `.` идёт первым параметром, то это значит, что будет копироваться вся директория целиком.

Контекст — это директория, относительно которой работает первый параметр в `COPY`. Обычно контекстом указывают ту директорию, которая содержит *Dockerfile*. Но это не обязательно, ведь контекстом может быть и другая директория:

```bash
# Указана директория уровнем выше
# Dockerfile должен лежать в текущей директории, из которой идет запуск
docker build -t something ..
```

Во время сборки образа, контекст целиком копируется внутрь системных директорий Docker, из которых в образ переносится всё, что указано в `COPY`. Из-за этого могут возникать проблемы: могут копироваться ненужные файлы/директории, чтобы это избежать создаётся файл `.dockerignore`, принцип его работы аналогичен `.gitignore`.

#### RUN

```dockerfile
# Если базовый образ Ubuntu, то доступен apt
RUN apt-get update && apt-get install -q curl

RUN npm install
```

Команда `RUN` выполняет переданную строчку в терминале от ползьователя `root`. С помощю этой команды выполняются основные изменения ФС, добавляются пакеты, ставятся зависимости и т.д.

`RUN` можно добавлять любой количество раз, обычно на одно действие делают одну команду.

`RUN` выполняется в не интерактивном режиме, поэтому если команда запрос ввод, то это приведёт к ошибке сборки образа. Поэтому все команды, запускаемые через `RUN`. Нужно запускать в неинтерактивном режиме.

#### CMD

```dockerfile
CMD ["npm", "start"]
```

`CMD` задаёт команду, которая выполняется при запуске контейнера по умолчанию. Она используется только в том случае, если контейнер был запущен без указания команды.

#### ENV

```dockerfile
ENV FASTIFY_ADDRESS 0.0.0.0
ENV VERSION 1
```

Задаёт пременные окружения. Команды, выполняющиеся после `ENV`, видят эти переменные и могут их использовать.

С командой надо быть осторожнее, т.к. Dockerfile фиксирует их значения.

В большинстве случаев пременные окружения передаются снаружи для конкретного запуска:

```bash
docker run -it -p 3000:3000 -e NODE_ENV=production hexlet/docker-fastify-example
```

[Docker Documentation: Dockerfile reference](https://docs.docker.com/engine/reference/builder/)

## Docker Compose

Docker Compose позволяет управлять набором контейнеров, каждый из которых представяляет собой один сервис проекта. Управление включает в себя сборку, запуск с учетом зависимостей и  конфигурацию. Конфигурация Docker Compose описывается в файле  _docker-compose.yml_, лежащем в корне проекта. 

Пример _docker-compose.yml_:

```yaml
# Версия схемы, которую мы используем.
# Зависит от установленной версии docker
# https://docs.docker.com/compose/compose-file/
version: "3"
# Определяем список сервисов — services
# Эти сервисы будут частью нашего приложения
services:

  app: # Имя сервиса
    build:
      # Контекст для сборки образа,
      # в данном случае, текущая директория
      context: .
      # Имя Docker-файла из которого будет собран образ
      dockerfile: Dockerfile
      # Команда, которая будет выполнена после старта сервиса
    command: make start
    ports: # Проброс портов
      - "3000:8000"
    # Перечисляем тома (volumes)
    # Они будут подключены к файловой системе сервиса
    # Например, все что находится в . мы увидим в директории /app
    volumes:
      # Текущая директория пробрасывается в директорию /app внутри контейнера
      # Путь внутри контейнера (после двоеточия) обязательно должен быть абсолютным
      - ".:/app"
      - "/tmp:/tmp"
    # Сервис будет запущен, только после старта db
    depends_on:
      - db

  db:
    # Имя образа. Здесь мы используем базу данных Postgres
    image: postgres:latest
    environment:
      # А так задаются переменные окружения
      POSTGRES_PASSWORD: password
    volumes:
      - pgdata:/var/lib/postgresql/data

  volumes:
    pgdata:
```

Команды для работы с Docker Compose

```bash
# Собирает сервисы, описанные в конфигурационных файлах
docker compose build

# Запускает собранные сервисы
docker compose up

# Запуск контейнеров на фоне с флагом -d
docker compose up -d

# Если какой-то из сервисов завершит работу,
# то остальные будут остановлены автоматически
docker compose up --abort-on-container-exit

# Запустит сервис application и выполнит внутри команду make install
docker compose run application make install

# А так мы можем запустить сервис и подключиться к нему с помощью bash
docker compose run application bash

# Со флагом --rm запускаемые контейнеры будут автоматически удаляться
docker compose run --rm application bash

# Останавливает и удаляет все сервисы,
# которые были запущены с помощью up
docker compose down

# Останавливает, но не удаляет сервисы, запущенные с помощью up
# Их можно запустить снова с помощью docker-compose start
docker compose stop

# Перезапускает все остановленные и запущенные сервисы
docker compose restart
```

[Docker Documentation: Try Docker Compose](https://docs.docker.com/compose/gettingstarted/)

[Пример Makefile для работы с Docker Compose](https://github.com/hexlet-basics/hexlet-basics/blob/main/make-compose.mk)
