# Hello world

```go
// Определение пакета (выполняет роль неймспейсов) main
package main
// Импорт пакета fmt
import "fmt"
// Определение функции main
func main() {
  // Вызов функции Print из пакета fmt
  // Отступ 1 таб
	fmt.Print("Hello, World!")
}
```

Все Go-файлы начинаются с объявления пакета, к которому они относятся.

`main()` — главная функция, выполняемая при запуске любой Go-программы, является точкой входа, не может принимать или возвращать какие-либо аргументы.

После названия пакета распологается блок импорта.

В Go:

* публичные функции пишутся с большой буквы;
* приватные с маленькой.

Для строк в основном используются двойные кавычки `"`.

**Для отступов используются только табы**

## GO

Go — компилируемый и стороготипизируемый язык.

В Go нет исключений. Вместо них используется встроенный интерфейс `error`. Ошибки возвращаются явно последним аргументом из функции. Поэтому Go-код выглядит как череда вызовов функций и проверок на ошибки:

```go 
func main() {
    msg, err := DecodeJSON("")
    if errors.Is(err, errEmptyMessage) {
        // { } empty message
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON("hello")
    if err != nil {
        // { } unmarshal: invalid character 'h' looking for beginning of value
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON(`{"sender":"hexlet","text":"Go,Go,Go"}`)
    // {hexlet Go,Go,Go} <nil>
    fmt.Println(msg, err)
}
```

Самая сильная сторона Go — простое написание конкуретных программ. Для это используются легковесные потоки — горутины. Пример программы суммирующей 10 значений из разных источников:

```go
import (
    "fmt"
    "sync"
)

func main() {
    mu := sync.Mutex{}
    wg := sync.WaitGroup{}

    sum := 0
    for i := 0; i < 10; i++ {
        wg.Add(1)

        // ставим перед любой функцией слово «go», и она выполняется конкурентно в горутине
        go func() {
            // делаем долгий вызов к стороннему API. Так как каждый вызов происходит в своей горутине, мы делаем 10 вызовов одновременно
            n := externalHTTPNum()

            mu.Lock()
            sum += n
            mu.Unlock()

            wg.Done()
        }()
    }

    // ждем, пока все 10 горутин вернут ответ
    wg.Wait()

    fmt.Println(sum) // 55
}
```

## Переменные

Существуют два способа объявления переменных:

* Длинная запись с использованием `var`:

```go
var num int = 10
// или
var num = 10
```

* Короткая запись:

```go
num := 10
```

Изменение значений:

```go
// двоеточие используется только при инициализации
num := 10
num = 20
```

Переменные принято называть в `camelCase`.

Если не завадать значение переменной при инициализации она будет иметь нулевое значение:

```go
var {
  a string // ""
  b bool // false
  c int // 0
}
```

Объявлять переменные можно на уровне функций и пакетов. Прерменные на уровне пакетов будут инициализированны при старте программы. Такие переменные используются не часто. Например, в них можно записывать статические ошибки:

```go
package math

import "errors"

// статичная ошибка
var errCannotSum = errors.New("cannot sum")

func sum(...)
```

В Go принято называть переменные наиболее просто в макимально скоращённом, но доступном для понимания виде:

```go
// плохо
message := ""
buffer := bytes.Buffer{}
// хорошо
msg := ""
buf := bytes.Buffer{}
```

## Функции

Объявляются через ключевое слово `func`:

```go
func multiply(x int, y int) int {
  return x * y
}
```

Здесь:

* `func` — ключевое слово;
* `multiply` — название;
* `(x int, y int)` — входящие аргументы, если несколько аргументов имеет один тип, то можно сократить до `(x, y int)`
* `int` – тип возвращаемого значения

Функции именуются в `camelCase`, если функция именуется с заглавной буквы, то функция экпортируемая (публичная), если с маленькой то доступна только в рамках текущего пакета (приватная).

Функция может возвращать несколько значений, чаще всего это используется для возвращения ошибок:

```go
package math

import "errors"

func divide(x, y int) (int, error) {
    if y == 0 {
        return 0, errors.New("cannot divide on zero")
    }

    return x / y, nil
}
```

Возвращаемые значения можно именовать:

```go
func multiply(x, y int) (res int) {
    res = x * y
    return
}
```

Однако, это сичтается плохой практикой.

При использовании внешней функции нужно указывать имя пакета и через `.` вызываеть публичную функцию.

```go
import "fmt"

func myPrint(msg string) {
    // пакет.функция
    fmt.Println(msg)
}
```

В Go есть специальный синтаксис для функций, которые можно вызывать с переменным количеством аргументов (**variadic functions**). Параметр, принимающий такие аргументы, нужно поставить последним в списке, а перед его типом — многоточие.

```go
func Sum(x ...int) int
```

Внутри функции этот параметр рассматривается как нумерованная последовательность аргументов (slice).

```go
func Sum(x ...int) (res int) {
    for _, v := range x {
        res += v
    }
    return
} 
```

Вызывают такую функцию обычным образом, со списком аргументов через запятую:

```go
sum := Sum(2, 3, 5, 1, 2, 57) 
```

Если вызвать эту функцию без аргументов `Sum()`, параметр `x` примет значение `nil`. Тогда цикл не пройдёт ни одной итерации, и функция вернёт `0`.

### Возвращение множества значений

Функция может возвращать не одно, а несколько значений разных типов.

```go
func foo() (int, int, string) 
```

При вызове такой функции должны быть предоставлены переменные, которым надо все эти значения присвоить.

```go
x, y, z := foo() 
```

А если некоторые значения не нужны, можно воспользоваться переменной `_`.

```go
_, y, _ := foo() 
```

Список возвращаемых значений имеет тот же синтаксис, что и список параметров.

Возращаемым значениям можно задавать имена. В теле функции они могут использоваться как обычные переменные. При входе в функцию они будут инициализированы значениями по умолчанию для данного типа.

Если функция содержит именованные возвращаемые значения, то необязательно указывать список возвращаемых значений оператором `return`. В таком случае будут возвращены значения переменных, которые они имеют к этому моменту.

Вот функция, которая находит индекс буквы в строке и возвращает вторым аргументом `false`, если буква не найдена:

```go
func Index(st string, a rune) (index int, ok bool) {
    for i, c := range st {
        if c == a {
            return i, true
        }
    }
    return // вернутся значения по умолчанию
} 
```

Если количество и тип возвращаемых функцией значений

```go
func foo() (int, int) 
```

в точности соответствуют параметрам другой функции,

```go
func bar(x int, y int) 
```

то допускается такой синтаксис вызова:

```go
bar(foo()) 
```

### Замыкания

## Замыкания

Go — язык с **лексической областью видимости (lexically scoped)**. Это значит, что переменные, определённые в окружающих блоках видимости (например, глобальные переменные), доступны функции всегда, а не только на время вызова. Можно считать, что функция их запоминает.

Лексическая область видимости и анонимные функции позволяют реализовать **замыкания (closure)**.

Вот классический пример итератора чётных чисел, построенного на замыкании:

```go
func Generate(seed int) func() {
    return func() {
        fmt.Println(seed) // замыкание получает внешнюю переменную seed
        seed += 2 // переменная модифицируется
    }
    
}

func main() {
    iterator := Generate(0)
    iterator()
    iterator()
    iterator()
    iterator()
    iterator()
} 
```

Замыкание привязывает к себе внешнюю переменную. После выхода из внешней функции `Generate` она не уничтожается, а остаётся привязанной к функции замыкания, причём её значение сохраняется между вызовами функции.

Получаем:

```
0
2
4
6
8 
```

Пример использования замыканий в функциях для подсчёта количества вызовов и времени выполнения:

```go
// countCall — функция-обёртка для подсчёта вызовов
func countCall(f func(string)) func(string) {
    cnt := 0
    // получаем имя функции.
    funcname := runtime.FuncForPC(reflect.ValueOf(f).Pointer()).Name()
    return func(s string) {
        cnt++
        fmt.Printf("Функция %s вызвана %d раз\n", funcname, cnt)
        f(s)
    }
}

// metricTimeCall — функция-обёртка для замера времени
func metricTimeCall(f func(string)) func(string) {
    return func(s string) {
        start := time.Now() // получаем текущее время
        f(s)
        fmt.Println("Execution time: ", time.Now().Sub(start)) // получаем интервал времени как разницу между двумя временными метками
    }
}

func myprint(s string) {
    fmt.Println(s)
}

func main() {

    countedPrint := countCall(myprint)
    countedPrint("Hello world")
    countedPrint("Hi")

    // обратите внимание, что мы оборачиваем уже обёрнутую функцию, а значение счётчика вызовов при этом сохраняется
    countAndMetricPrint := metricTimeCall(countedPrint)
    countAndMetricPrint("Hello")
    countAndMetricPrint("World")

}
// Результат

Функция main.myprint вызвана 1 раз
Hello world
Функция main.myprint вызвана 2 раз
Hi
Функция main.myprint вызвана 3 раз
Hello
Execution time:  3.147µs
Функция main.myprint вызвана 4 раз
World
Execution time:  3.16µs
```

### Особенные функции

Точка входа в программу — функция `main()`. Она обязательно должна существовать в единственном виде и в любой исполняемой программе на Go. `main()` не принимает аргументов и не возвращает значений.

В Go есть встроенные функции, например: `make()`, `new()`, `len()`, `cap()`, `delete()`, `close()`, `append()`, `copy()`, `panic()`, `recover()`. Это не библиотечные функции. Они не вполне подчиняются правилам для функций пользователя. У них может не быть сигнатуры, а их использование документировано в спецификации языка — основополагающем для Go документе.

В базовом синтаксисе языка также описана вот эта функция:

```go
func init() { … } 
```

В пакете и даже в одном файле можно декларировать несколько таких функций. Они будут вызваны один раз при инициализации пакета, после присвоения глобальных переменных, в том порядке, в котором они предоставлены компилятору (встречаются в исходном тексте). Прямой вызов функции `init()` в коде программы не предусмотрен.

Служат эти функции для создания окружения, необходимого пакету для корректной работы.

Вот простой пример:

```go
var name, surname string

func init() {
    name = "John"
}
func init() {
    if surname == "" {
        surname = "Doe"
    }
}
func main() {
    fmt.Println("Hello " + name + " " + surname)
} 
```

## Числа и операции с ними

В Go есть множество числовых типов данных: uint`, `uint8`, `uint16`, `uint32`, `uint64`, `int`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`, `complex64`, `complex128.

Это нужно для кросплатформенность, в коде достаточно использовать `int` и `unit`, а в момент компиляции они будут преобразованные в необходимые типы для целевой архитектуры.

В основом коде используют:

- `int` — основной кросплатформенный тип целых чисел, может быть отрицательным
- `int64` нужен для больших чисел из внешних систем. Например, ID в СУБД имеет тип `bigint`. Чтобы правильно распарсить такой ID, используется `int64`
- `float64` — число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max()`, определяющая наибольшее число, принимает аргументы в виде `float64`

Стандартные арифметические операции:

```go
x := 10
y := 5

// сложение
x + y // 15
// вычитание
x - y // 5
// деление
x / y // 2
// умножение
x * y // 50
```

Любые операции осуществляются только над числами одного типа.

Чтобы работать с несколькими типа необходимо использовать явное приведения к типу:

```go

x := 5.05
y := 10

x + float64(y)  // 15.05
```

В основом числовые типы конвертируются без проблем между собой, но нужно учитывать некоторые нюансы:

```go
// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer
x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```

## Логические типы

Логичесие типы представлены `true` и `false`, а также операторами:

* `&&` (и)
* `==` (равно)
* `||` (или)
* `!` (не)

Объявление происходит через ключевое слово `bool`:

```go
var b bool = true
bs := false
```

Для проверки не логических типов нужно приводить их к логическим выражениям:

```go
flag := true
text := "hello"

// вариант не сработает, потому что нельзя конвертировать строку в bool
flag && bool(text) // cannot convert text (type string) to type bool

// правильный вариант: если строка не пустая, то в ней есть текст
flag && text != "" // true
```

## Строки

Строки объявляются с типом `string`:

```go
var s string = "hello"

// сокращенная запись
s := "hey"
```

Практически всегда используются довойный ковычки, кроме случая, когда нужно объявить несколько строк, в этом случае используются обратные кавычки:

``` go
q := `
    SELECT *
    FROM person
    WHERE age > 18
`
```

Строки можно сравинивать операторами, строки сравниваются посимвольно в лексическом порядке (по алфавиту) и по длине. Это свойство часто используется при сортировке массива строк:

```go
"привет" == "привет" // true
"golang" > "go" // true
"golang" > "lang" // false
"go" > "foobar" // true
```

Конкатенация осуществляется с помощью `+`.

В Go интерполяция осуществляется черезз функцию `fmt.Sprintf()`:

```go
username := "Ivan"
greetings := fmt.Sprintf("hello, %s", username) // "hello, Ivan"
```

Узнать длину строки можно с помощью встроенной функции `len()`:

```go
len("go") //2
// функция сичитает количество байт, а не реальную длину строки
len("го") // 4
```

## Условные конструкции

Условия представленые конструкцией `if else`. В условии должно быть выражение логического типа:

```go
package main

import (
    "fmt"
    "strings"
)

func statusByName(name string) string {
    // функция проверяет, что строка name начинается с подстроки "Mr."
    if strings.HasPrefix(name, "Mr.") {
        return "married man"
    } else if strings.HasPrefix(name, "Mrs.") {
        return "married woman"
    } else {
        return "single person"
    }
}

func main() {
    n := "Mr. Doe"
    fmt.Println(n + " is a " + statusByName(n)) // Mr. Doe is a married man

    n = "Mrs. Berry"
    fmt.Println(n + " is a " + statusByName(n)) // Mrs. Berry is a married woman

    n = "Karl"
    fmt.Println(n + " is a " + statusByName(n)) // Karl is a single person
}
```

Логическое выражение пишется после `if` без скобок. `else if` можно написать только раздельно.

В Go применяется «ленивая» проверка условий: она идёт слева направо до первого `false` и прекращается, потому что проверять дальше нет смысла. Пример «ленивой» проверки:

```go
a, b := 1, 0

if a == 1 || b == 2 {
    fmt.Println("Hello")
} 
```

В данном примере выполняется левое условие, поэтому проверки (или выполнения) правой части не последует. Пример будет более показателен, если для правой части условия использовать функциональный литерал (подробнее расскажем в теме «Функции»), который будет просто изменять значение переменной `b`.

```go
a, b := 1, 0

incB := func() bool {
    b = b + 1
    return true
}

if a == 1 || incB() {
    fmt.Println("Hello")
}

fmt.Println(a, b) // 1 0 
```

Из-за «ленивой» проверки условий функция `incB` не выполнится — её значение не изменится, то есть функция не изменит значение переменной, потому что выполнение кода прервётся.

Оператор `if` может состоять из двух компонент: инициализации и основного условия. Такая техника позволяет объявлять локальную переменную, которую используют только в рамках области видимости `if`. Это может пригодиться, например, когда нужно преобразовать данные для сравнения. 

```go
a := 0.10000001 // float64
// инициализация и основное условие
if b := float32(a); b > float32(0.1) {
    fmt.Println("Var a is GT float32(0.1)")
} 
```

Условие в данном примере может перестать выполняться, если добавить ещё один ноль: `0.100000001`. Тип `float32` обеспечивает точность в восемь десятичных чисел, в то время как точность `float64` составляет около 15 чисел.

## Switch

Switch по синтаксису схож с реализацией в других языках, но по логике отличается, если в кое-либо условие выполняется, то выполняется блок этого условия и происходит выходит из switch, использание `break` для этого не требуется:

 ```go
 x := 10
 
 switch x {
     default: // default всегда выполняется последним независимо от расположения в конструкции
         fmt.Println("default case")
     case 10:
         fmt.Println("case 10")
 }
 //Output: case 10
 ```

При необоходимости можно реализовать логику, чтобы выполнение не прерывалось, для этого используется `fallthrough`:

```go
x := 10

switch { // выражение отсутствует. Для компилятора выглядит как: switch true
    default:
        fmt.Println("default case")
    case x == 10:
        fmt.Println("equal 10 case")
        fallthrough
    case x <= 10:
        fmt.Println("less or equal 10 case")
}
Output:

equal 10 case
less or equal 10 case
```

**Стоит учитывать, что `fallthrough` переводит выполнение к следующему блоку, даже если выражение в усолвии не выполняется**

Особенности `fallthrough`:

- его можно использовать только в последней строке `case`, иначе будет ошибка компиляции;
- оно игнорирует условие следующего по порядку `case`.

Внутри `switch` можно объявить локальную переменную, доступную только в пределах области видимости оператора:

```go
a := 6
switch b := a % 5; {
case b == 0:
    fmt.Println("Кратно 5")
default:
    fmt.Printf("Остаток от деления на 5: %d", b)
} 
```

## Структуры

В Go нет классов и привычной реализации ООП. Вместо классов используются структуры — наборы полей, Имеющих название и тип данных. Объявление стуктуры имеет следующий вид:

```go
type Person struct {
    // [название поля] [тип данных]
    Name string
    Age int
}

func main() {
    p := Person{Name: "John", Age: 25}

    p.Name // "John"
    p.Age // 25
}
```

Структуру можно инициализировать, не передавая значения. В этом случае каждое поле примет свое «нулевое» значение:

```go
func main() {
    p := Person{}

    p.Name // ""
    p.Age // 0
}
```

Регистр первой буквы в структурах обозначает публичность, так же как в переменных и функциях.

У любого поля структуры можно указать теги. Они используются для  метаинформации о поле для сериализации, валидации, маппинга данных из БД и тд. Тег указывается после типа данных:

```go
type User struct {
    ID int64 `json:"id" validate:"required"`
    Email string `json:"email" validate:"required,email"`
    FirstName string `json:"first_name" validate:"required"`
}
```

Тег `json` используется для названий полей при сериализации/десериализации структуры в json и обратно:

```go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID        int64  `json:"id"`
    Email     string `json:"email"`
    FirstName string `json:"first_name"`
}

func main() {
    u := User{}
    u.ID = 22
    u.Email = "test@test.com"
    u.FirstName = "John"

    bs, _ := json.Marshal(u)

    fmt.Println(string(bs)) // {"id":22,"email":"test@test.com","first_name":"John"}
}
```

Тег `validate` используется Go-валидатором.

```go
package main

import (
    "fmt"
    "github.com/go-playground/validator/v10"
)

type User struct {
    ID        int64  `validate:"required"`
    Email     string `validate:"required,email"`
    FirstName string `validate:"required"`
}

func main() {
    // создали пустую структуру, чтобы проверить валидацию
    u := User{}
    // создаем валидатор
    v := validator.New()
    // метод Struct валидирует переданную структуру и возвращает ошибку `error`, если какое-то поле некорректно
    fmt.Println(v.Struct(u))
}
```

### Конструктор

В Go нет синтаксиса конструкторов и деструкторов, но часто можно встретить аналог:

```go
   func NewPerson(name, email string, dobYear, dobMonth, dobDay int) Person {
       return Person{
           Name:        name,
           Email:       email,
           dateOfBirth: time.Date(dobYear, time.Month(dobMonth), dobDay, 0, 0, 0, 0, time.UTC),
       }
   } 
```

Некоторые правила, одобренные Go-сообществом:

- имя функции конструктора пишут с префиксом `New`;
- если конструктор производит валидацию аргументов, функция должна возвращать ошибку последним аргументом.

Подход применяют:

- когда нужно производить валидацию аргументов, чтобы построить логически правильный объект;
- когда построение экземпляра объекта требует дополнительных действий, например, подключения к базе данных.

### Анонимные структуры

Анонимные структуры объявляются и используются непосредственно в коде. Отдельный тип для них не описывают, потому что анонимные структуры применяются однократно, и описание имеет смысл только для конкретной части кода: например, при сериализации/десериализации сообщений. Чаще всего анонимные структуры используют в тестах для описания тестовых структур.

Проще всего понять концепцию анонимных структур из следующего соображения:

```go
type Person struct {
    Name string 
} 
```

Конструкция `type Person ...` на самом деле не описывает, а создаёт тип на основе существующего и называет его. То есть по факту тип создаёт именно конструкция `struct{}`. 

Получив такой анонимный тип, можно сразу же создать переменную этого типа.

Приведём пример использования анонимной структуры при построении REST-запроса:

```go
req := struct {
    NameContains string `json:"name_contains"`
    Offset       int    `json:"offset"`
    Limit        int    `json:"limit"`
}{
    NameContains: "Иван",
    Limit:        50,
}

reqRaw, _ := json.Marshal(req)
fmt.Println(string(reqRaw)) // {"name_contains":"Иван","offset":0,"limit":50}
```

### struct{}

```go
var c struct{}
// или
c := struct{}{}

fmt.Println(unsafe.Sizeof(c)) // 0
fmt.Println(unsafe.Pointer(&c))  // 0x11d46e8 
```

Размер `struct{}` равен `0`, при этом объект `c` имеет адрес. Такую лазейку можно использовать для оптимизации кода по памяти

## Константы

Константы объявляются через `const`:

```go
const StatusOk int = 200
```

На практике констакты обычно объявляются так:

```go
const (
    StatusOk = 200
    StatusNotFound = 404
)
```

Для констант допустимы такие типы данных:

* Строки;
* Числа;
* Логические типы;

Регист первой буквы название влияет на уровнь доступа константы.

Константы можно объявлять как не уровне функций, так и пакета:

```go
package main

import "fmt"

const defaultStatus = 200

func main() {
    const status = 404

    fmt.Println("default status:", defaultStatus) // default status: 200
    fmt.Println("current status:", status) // current status: 404
}
```

Именнованные константы могут быть разного типа, тип связан с хранимым значением.

```go
const intConst = 5 
const floatConst = 5.0
const runeConst = 'A'
const strConst = "Hello, world!"
const boolConst = true 
```

Может показаться, что если опустить тип при объявлении константы, то компилятор выберет его сам — как в случае с короткой формой объявления переменных. Это так лишь отчасти. В случае с константами отсутствие явного указания типа имеет большее значение.

Например, если вы объявляете константу `intConst` и присваиваете ей значение `5`, то получаете **целочисленную константу с неопределённым типом** (`untyped int`). Конкретный тип значения этой константы ещё не определён и в разных контекстах будет интерпретироваться компилятором по-разному. Это позволяет ослабить типизацию для констант, не отказываясь от сильной типизации глобально.

Благодаря этому подходу будет работать следующий пример:

```go
package main

import (
    "fmt"
)

const id = 100

func main() {
    var i int64 = id
    var f float64 = id

    fmt.Println("i=", i, "f=", f) // i = 100 f = 100 
} 
```

Если в группе констанкт не указано значение, то оно будет равно значению предыдущей константы:

```go
const (
    pi = 3.1415
    e
    name = "John Doe"
    fullName
)

func main() {
    fmt.Println("pi =", pi, "e =", e) // pi = 3.1415 e = 3.1415
    fmt.Println("name =", name, "fullName =", fullName) // name = John Doe fullName = John Doe
}
```

### `iota`

Для последовательных числовых констант следует использовать идентификатор `iota`, который присвоит для списка чисел значения от его текущей позиции:

```go
package main

import "fmt"

const (
    zero = iota
    one
    two
    three
)

const (
	a = iota
	b = 42
	c = iota
	d
)

func main() {
	fmt.Println(zero, one, two, three) // 0 1 2 3
	fmt.Println(a, b, c, d)            // 0, 42, 2, 3
}
```

`iota` можно также использовать в арифметических выражениях, чтобы быстро объявить ряд значений с прогрессией. Следует помнить, что `iota` увеличивается на единицу для каждой строки, где указано имя константы, даже если той было присвоено конкретное значение.

```go
const (
    _ = iota*10  // обратите внимание, что можно пропускать константы 
    ten
    twenty
    thirty
)

const (
    hello = "Hello, world!"  // iota равна 0
    one = 1                  // iota равна 1

    black = iota   // iota равна 2
    gray
)

func main() {
    fmt.Println(ten, twenty, thirty) // 10 20 30
    fmt.Println(black, gray) // 2 3
}
```

### Пользовательские типы констант

Предположим, нужно определить константы для дней недели. 

```go
const (
    Monday = iota + 1
    Tuesday
    //...
    Sunday
) 
```

Если перечислить их так, то все константы будут иметь нетипизированный числовой тип и могут использоваться в любых выражениях, что может вносить путаницу: `var i int = Monday + 1`. В подобных случаях стоит определить пользовательский тип и указать его при определении констант.

```go
type Weekday int

const (
    Monday Weekday = iota + 1
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)

func NextDay(day Weekday) Weekday {
    return (day % 7) + 1
}

func main() {
    var today Weekday = Sunday
    tomorrow := NextDay(today)
    fmt.Println("today =", today, "tomorrow =", tomorrow) // today = 7 tomorrow = 1 
} 
```

## Литералы

В Go можно использовать различные представления строковых и числовых литералов. Проиллюстрируем на примере целого числа `1000`:

```go
1000
1000.0
1_000 // можно разделять части числа символом '_' для удобства восприятия
01750 // восьмеричное представление, начинается с 0
0x3e8 // шестнадцатеричное представление
0b001111101000 // бинарное представление 
```

Любой из этих литералов может быть использован в выражениях и даст одно и то же значение. 

## Цикл for

Обход коллекций осуществляется только через цикл `for`:

```go
nums := make([]int, 0, 10)

// начиная с 0; пока i меньше 10; инкрементим i после каждого шага
for i := 0; i < 10; i++ {
    nums = append(nums, i)
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

При необходимости `for` используется как `while`:

```go
i := 0
nums := make([]int, 0, 10)

for i < 10 {
    nums = append(nums, i)
    i++
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Если опучстить условие, то можно уйти в бесконечный цикл.

Если условное выражение возвращает `false` или был вызыван `break` в теле цикла, то происходит остановка цикла. Для перехода к следующей итерации используется `continue`:

```go
nums := make([]int, 0, 10)

// добавляем только четные числа в слайс
for i := 0; i < 10; i++ {
    if i % 2 != 0 {
        continue
    }

    nums = append(nums, i)
}

fmt.Println(nums) // [0 2 4 6 8]
```

Для обхода коллекции есть `range`:

```go
names := []string{"John", "Harold", "Vince"}

// i — это индекс, name — это значение на текущем шаге цикла
for i, name := range names {
    fmt.Println("Hello ", name, " at index ", i)
}
```

## Массивы

Массив — коллекция однотипных значений, фиксированной длины:

```go
nums := [5]int{}
```

Длина массива указвается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:

```go
nums := [5]int{} // [0, 0, 0, 0, 0]
// длинная инициализация
var nums [5]int // [0, 0, 0, 0, 0]
```

При попытке инициализации элементов за границей массива выходит ошибка компиляции:

```go
nums := [1]int{1,2} 
```

Количество элементов в массиве может быть выведено автоматически по длине списка инициализации. Для этого используется следующая конструкция:

```go
rgbColor := [...]uint8{255, 255, 128} // [255 255 128] len = 3
rgbaColor := [...]uint8{255, 255, 128, 1} // [255 255 128 1] len = 4 
```

В списке инициализации можно указать только нужные элементы и их индексы. Индекс и значение указываются через двоеточие. 

```go
thisWeekTemp := [7]int {6:11, 2:3} // [0 0 3 0 0 0 11] 
```

Чтение и запись происходит через квадратные скобки:

```go
nums := [3]int{1, 2, 3}
fmt.Println(nums[1]) // 2

nums[2] = 33
fmt.Println(nums) // [1, 2, 33]
```

Нумерация элементов массива начинается с 0, при попытке чтения за границей будет ошибка компиляции.

Массивы передаются по значению — т.е. лебое изменение внутри функции не виляет на исходный массив.

В Go есть встроенная функция `len()`, которая возвращает длину массива:

```go
fmt.Println(len([5]int{1,2,3})) // 5
fmt.Println(len([10]int{})) // 10
```

Так как массивы инициализируются с фиксированной длинной, то функция `len()` всегда возвращает одно и то же значение.

### Обход массива

Для обхода используется циклы:

```go
var weekTemp = [7]int{5, 4, 6, 8, 11, 9, 5} 

sumTemp := 0

for i:= 0; i < len(weekTemp); i++ {
    sumTemp += weekTemp[i]
}

average := sumTemp / len(weekTemp)
```

Для последовательного обхода можно использовать констурукцию `for range`:

```go
var weekTemp = [7]int{5, 4, 6, 8, 11, 9, 5} 

sumTemp := 0

for _, temp := range weekTemp { // первая переменная индеекс, вторая — значение
    sumTemp += temp
}

average := sumTemp / len(weekTemp)
```

Оператор `range` на каждой итерации возвращает индекс и значение следующего элемента в массиве.

### Преимущества применения массивов

1. Элементы массива всегда располагаются в памяти последовательно, это ускоряет выполнение программы.
2. Массивы имеют фиксированную длину, поэтому выделение памяти под массив происходит ровно один раз в момент его объявления.
3. Время доступа к элементам массива минимальное.
4. Go проверяет выход за пределы массива на этапе компиляции, если может вычислить значение индекса элемента на этапе компиляции, и во время исполнения программы. В первом случае будет ошибка компиляции, а во втором — паника. Панику лучше не допускать.

### Недостатки применения массивов

1. Массивы могут быть только фиксированной длины: если количество элементов нам заранее неизвестно, память придётся выделять с запасом.
2. Массивы передаются и присваиваются с полным копированием элементов, что грозит внезапным ухудшением производительности и увеличенным расходом памяти.
3. Для обработки массивов разных габаритов придётся писать разные функции (если не используются дженерики).

Массивы следует применять крайне обдуманно, когда размеры вашего массива точно известны на этапе компиляции. Это позволяет ускорить работу программы.

Чтобы исправить недостатки массивов, в Go введены слайсы.

## Слайсы

Слайсы — массив неопределённой длины (или динамический массив):

```go
var nums = []int{1,2,3}

nums := []int{1,2,3}
```

Чтение и запись осуществляется так же как в массиве:

```go
nums := []int{1,2,3}
nums[2] // 3
nums[0] = 10 // [10, 2, 3]
// с помощью оператора : можно получить элементы от нижней до верхней границы
nums[1:3] // [2, 3]
nums[:2] // [10, 2]
nums[2:] // [3]
```

В слайсы можно добавить элементы с помощью встроенной функции `append`:

```go
words := []string{"hello"}

words = append(words, "world") // ["hello", "world"]
```

Внутри себя слайс, помимо самих элементов, хранит 2 дополнительных свойства: длину массива (`len`) и вместимость массива ( `cap`). Благодаря этому можно инциализровать слайс нужной длины с помощью функции `make`:

```go
// len = 5. Массив сразу будет заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5. Массив будет пустым, однако заполнение слайса через append будет эффективным, потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
```

Слайс — это обёртка над указателем массива.

Передача слайса в качестве аргумета функции происходит так: длина и вместимость передаются по значению, но массив значений передаётся по ссылке, таким образом выходит, что добавление элементов не сохраняется в исходный слайд, но изменение остаются:

```go
package main

import (
    "fmt"
)

func main() {
    nums := []int{1, 2, 3, 4, 5}

    modifySlice(nums)

    fmt.Println(nums) // [1 2 10 4 5]
}

func modifySlice(nums []int) {
    nums[2] = 10 // элемент будет и в исходном слайсе
    nums = append(nums, 6) // элемент не добавится в исходный слайс
}
```

Для слайсов можно распаковывать значение с помощью `...`:

```go
nums := []int{1, 2, 3, 4, 5}
nums[]...
```

### Копирование слайсов

Функция `copy(dst, src []Type) int` копирует слайс `src` в слайс `dst` и возвращает колиечство скопированных элементов:

```go
nums := []int{1,2,3,4,5}

// важно инициализировать слайс той же длины
numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp) // [1,2,3,4,5]
```

При копировании выжно соответствие длины слайсов, если если элементы будут выходить за длину `dst` то они не будут скопированны:

```go
nums := []int{1, 2, 3, 4, 5}

// создали слайс с длиной 0
numsCp := make([]int, 0)

// при копировании в пустой слайс ничего не произойдет
copy(numsCp, nums)

fmt.Println(numsCp) // []
```

### Сортировка слайсов

Стандартный пакет `sort` предоставляет функции для сортировки:

```go
nums := []int{2,1,6,5,3,4}

sort.Slice(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Рассмотрим функцию `Slice(x interface{}, less func(i, j int) bool)`. Следует запомнить, что пустой интерфейс `interface{}` в Go означает тип данных, под который подходит любой другой тип.

В функцию `Slice(x interface{}, less func(i, j int) bool)`  передается слайс любого типа данных, как первый аргумент. Вторым  аргументом передается функция, которая берет элементы по индексу и  определяет должен ли элемент по индексу `i` находиться перед элементом по индексу `j`.

Внутри функции **sort.Slice** используется быстрая сортировка. В пакете также присутствует сортировка вставками `sort.SliceStable`:

```go
nums := []int{2,1,6,5,3,4}

sort.SliceStable(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Выбор алгоритма зависит от набора и размера данных, архитектуры  процессора, скорости доступа к памяти, то есть от многих факторов. Для  большинства стандартных случаев используется `sort.Slice`

### Полезные приёмы для работы со слайсами

Удаление последнего элемента слайса:

```go
    s := []int{1, 2, 3}
    if len(s) != 0 { // защищаемся от паники
        s = s[:len(s)-1]
    }
    fmt.Println(s) // [1 2] 
```

Удаление первого элемента слайса:

```go
    s := []int{1,2,3}
    if len(s) != 0 { // защищаемся от паники
        s = s[1:]
    } 
    fmt.Println(s) // [2 3] 
```

Удаление элемента слайса с индексом `i`:

```go
    s := []int{1,2,3,4,5}
    i := 2
    
    if len(s) != 0 && i < len(s) { // защищаемся от паники
        s = append(s[:i], s[i+1:]...)
    } 
    fmt.Println(s) // [1 2 4 5] 
```

Сравнение двух слайсов:

```go
  s1 := []int{1,2,3}
    s2 := []int{1,2,4}
    s3 := []string{"1","2","3"}
    s4 := []int{1,2,3}

    fmt.Println(reflect.DeepEqual(s1,s2)) // false
    fmt.Println(reflect.DeepEqual(s1,s3)) // false
    fmt.Println(reflect.DeepEqual(s1,s4)) // true 
```

## Мап

Map — тип данных, предназначеный для хранения пар ключ-знамения (в других языках: хэш-таблица, словарь, асоциативный массив):

```go
// создание пустой мапы
var m map[int]string

// сокращенное создание пустой мапы
m := map[int]string{}

// рекомендуемое создание с обозначением размера
m := make(map[int]string, 10)

// создание мапы с элементами
m := map[int]string{1: "hello", 2: "world"}

// добавление элемента
m[3] = "!" // map[1:hello, 2:world, 3:!]

// чтение элемента
word := m[1] // "hello"
```

При чтении элемента по несуществующему ключу возвращается нулевое значение типа. При использовании bool как значения это приводит к ошибкам логики, для решения этого используется вторая переменная, в которую записывается наличие жлемента в мапе:

```go
elements := map[int64]bool{1: true, 2: false}

element, elementExists := elements[1] // true, true
element, elementExists := elements[2] // false, true
element, elementExists := elements[225] // false, false

// пустая структура struct{} — это тип данных, который занимает 0 байт
// используется, когда нужно проверять в мапе только наличие ключа
cache := make(map[string]struct{})

// проверяем есть ли ключ `key` в мапе
_, ok = cache["key"]
fmt.Println(ok)  // false

// добавим ключ и проверим вновь
cache["key"] = struct{}{}
_, ok = cache["key"]
fmt.Println(ok)  // true

```

Элементы удаляются с помощью функции `delete(m map[Type]Type1, key Type)`:

```go
engToRus := map[string]string{"hello":"привет", "world":"мир"}

delete(engToRus, "world")

fmt.Println(engToRus) // map[hello:привет]
```

Мапы всегда передаются по ссылке

## Обход мап

Как и слайс, мапу можно обойти с помощью `for range`:

```go
idToName := map[int64]string{1: "Alex", 2: "Dan", 3: "George"}

// первый аргумент — ключ, второй — значение
for id, name := range idToName {
    fmt.Println("id: ", id, "name: ", name)
}
```

Стоит учитывать, что порядок ключей в мапе рандомизирован.

## Строки и байты

Строки в Go — это иммутабельные массивы байт. Для стандартного компилятора Go внутренняя структура строки описана как:

```go
type _string struct {
    elements *byte // байты
    len      int   // кол-во байт
}
```

После инициализации строку нельзя изменить и такая иммутабельность позволяет избежать побочных эффектов в коде.

```go
s := "hello"
s[4] = "" // ошибка компиляции: cannot assign to s[4] (strings are immutable)
```

Стоит отметить, что тип данных `byte` — это алиас к типу `uint8` (0-255). Во-первых, потому что нужно абстрактно отличать типы в коде.  Во-вторых, байты представляют ASCII символы, а в кодовой таблице ASCII  символов 256 кодов:

```go
package main

import "fmt"

func main() {
    s := "hey"

    fmt.Println(s[0], s[1], s[2]) // 104 101 121

    fmt.Println(string(s[0]), string(s[1]), string(s[2])) // h e y
}
```

Большинство библиотечных функций работают со слайсами байт `[]byte` для производительности. Конвертация строки в слайс байт описывается в коде явно:

```go
package main

import "fmt"

func main() {
    s := "hey"
    bs := []byte(s)

    fmt.Println([]byte(s)) // [104 101 121]

    fmt.Println(string(bs)) // hey
}
```

Отдельные ASCII символы можно объявлять сразу с типом `byte`. Для этого нужно обернуть символ в одинарные кавычки и указать тип `byte`:

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    asciiCh := byte('Q')
    asciiChStr := string(asciiCh)

    fmt.Println(reflect.TypeOf(asciiCh), asciiCh) // uint8 90

    fmt.Println(reflect.TypeOf(asciiChStr), asciiChStr) // string Q
}
```

## Обход строки

Строки можно обходить с помощью `for`:

```go
package main

import (
    "fmt"
)

func main() {
    s := "hello"
    for i := 0; i < len(s); i++ {
        fmt.Println(string(s[i]))
    }

}
```

Однако, это корректно будет работать только со строками из ASCII символов, при работе с многобайтовыми строка вывод будет некорректным.

## Руны

Для работы с юникод-символами в Go есть тип `rune`:

```go
package main

import (
    "fmt"
)

func main() {
    emoji := []rune("привет😀")

    for i := 0; i < len(emoji); i++ {
        fmt.Println(emoji[i], string(emoji[i])) // выводим код символа и его строковое представление
    }
}
```

`rune` — алиас к `int32`. Как и байты, руны были созданы для отличия от встроенного типа данных. Каждая рунна — это код символа Юникода. Строка преобразуется в `byte[]` и `rune[]`, но между собой эти два типа не конвертируются напрямую.

В Go присутствует синтаксический сахар при обходе строки. Если использовать конструкцию `for range`, строка автоматически будет преобразована в `[]rune`, то есть обход будет по Юникод символам:

```go
package main

import (
    "fmt"
)

func main() {
    emoji := []rune("cool😀")

    for _, ch := range emoji {
        fmt.Println(ch, string(ch)) // выводим код символа и его строковое представление
    }
}
```

## Стандартный пакет strings

Для работы со строками существует пакет `strings`, который содержит основные функции. Например часто используются функции:

```go
import "strings"

// проверяет наличие подстроки в строке
strings.Contains("hello", "h") // true

// разбивает строку по Юникод символам или по переданному разделителю
strings.Split("hello", "") // ["h", "e", "l", "l", "o"]

// склеивает строки из слайса с разделителем
strings.Join([]string{"hello","world!"}, " ") // "hello world!"
```

Важная часть этого пакета —это `Builder`. Когда необходимо собрать большую строку по каким-то правилам лучше не использовать конкатенацию, а использовать `Builder`:

```go
import "strings"

sb := strings.Builder{}

sb.st("hello")
sb.WriteString(" ")
sb.WriteString("world")

sb.String() // "hello world"
```

[Пакет strings](https://pkg.go.dev/strings)

## Форматирование строк

Пакет `fmt` используется не только для вывода переменных или реультатов функций, но и для форматирования строк. Для подстановки значений используются плейсхолдеры:

```go
name := "Andy"

// подставляем строку
fmt.Sprintf("hello %s", name) // "hello Andy"

// число
fmt.Sprintf("there are %d kittens", 10) // "there are 10 kittens"

// логический тип
fmt.Sprintf("your story is %t", true) // "your story is true"
```

Также существуют специализированные плейсхолдеры, которые преобразуют сложные структуры:

```go
package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Andy", Age: 18}

    // вывод значений структуры
  	// simple struct: {Andy 18}
    fmt.Println("simple struct:", p)

    // вывод названий полей и их значений
  	// detailed struct: {Name:Andy Age:18}
    fmt.Printf("detailed struct: %+v\n", p)

    // вывод названий полей и их значений в виде инициализации
  	// Golang struct: main.Person{Name:"Andy", Age:18}
    fmt.Printf("Golang struct: %#v\n", p)
}
```

[Пакет fmt](https://pkg.go.dev/fmt)

## Вариативные функции

Последний аргумент функции может быть вариативным. Функция может иметь маскимум один вариативный агрумент и этот агрумент всегда слайс. Чтобы обозначить аргумент вариативным нужно поставить `…` перед его типом:

```go
package main

import (
    "fmt"
)

func main() {
    // кол-во аргументов может быть любым
    PrintNums(1, 2, 3)
}


func PrintNums(nums ...int) {
    for _, n := range nums {
        fmt.Println(n)
    }
}
```

Также `…` можно разбить слайс на элементы при предаче в вариативную функцию. Например, метод `append(slice []Type, elems …Type) []Type` принимает вариативный аргумент `elems …Type`. Чтобы добавить один слайс в конец другого, нужно разить второй слайс на элементы путем добавления  `…` после переменной:

```go
nums1 := []int{1,2,3,4,5}
nums2 := []int{6,7,8,9,10}

res := append(nums1, nums2...) // [1 2 3 4 5 6 7 8 9 10]
```

## Указатели

Синтаксис переменной-указатели:

```go
var p *int
```

Здесь создали переменную типа «указатель на целое число». В Go можно создать указатель на любой тип данных.

Физически указатель — это ячейка памяти, хранящая адрес ячейки, на которую «смотрит» указатель. После создания указатель не «смотрит» ни на одну ячейку памяти в компьютере и имеет нулевое значение. Оно выглядит как `nil`.

Для того чтобы присвоить указателю значение (адрес какой-либо переменной), используется операция взятия адреса `&`:

```go
var a int = 5
p := &a

fmt.Println(a,p) //a=5 p=0xc0000b2008 
```

Значение указателя на 64-битном компьютере — это 64-битное число. Именно размер указателя на данной системе задаёт характеристику битности компьютера.

Чтобы получить значение указателя, в памяти должна быть переменная, на которую он «смотрит». Такое значение называется **адресуемым (adressable)**

Тип переменной, на которую создаётся указатель, должен соответствовать типу указателя.

Литералы композитных типов создают в памяти переменную соответствующего типа, поэтому указатель можно создать вот так:

```go
  type A struct {
      IntField int
  }
  // Литерал А{} создаёт в памяти переменную типа А. Затем от неё берётся указатель
  p := &A{ 
      IntField: 10,
  } 
```

А ещё в Go есть встроенная функция `new()`. В качестве параметра ей передаётся тип, а возвращается указатель на новую переменную соответствующего типа.

```go
    type A struct {
        IntField int
    }
    
    p := new(A) //  то же самое, что и &A{} 
```

Указатели ведут себя так же, как и обычные переменные. Их можно копировать, присваивая другим переменным тип указателя, передавать и возвращать в функции, а также создавать указатели уже на них. 

Тип указателя на указатель описывается как `**T`, например `**int`.

Чтобы получить или изменить значение, хранящееся по указателю, применяют оператор **разыменования** (**dereference**) `*`.

```go
i := 42
p := &i
fmt.Println(*p) // читаем значение переменной i через указатель p
*p = 21         // записываем в переменную i значение 21 через указатель p 
```

Вызов оператора разыменования на `nil`-указателе приведёт к панике на этапе исполнения кода, и программа откажется работать дальше.

```go
var p *int
fmt.Println(*p) // panic: runtime error: invalid memory address or nil pointer dereference 
```

### Указатели и структуры

Для указателей на структуры в Go есть возможность неявного разыменования при доступе к полям структуры.

```go
type A struct {
    IntField int
}

p := &A{}
p.IntField = 42 // вместо (*p).IntField = 42 
```

### Сравнение указателей

Для указателей определены операторы сравнения (`==`, `!=`). Два указателя равны, если они указывают на один и тот же объект в памяти либо если оба равны `nil`.

### Когда стоит использовать указатели

* Когда нужно изменить значение переменной из вызываемой функции. Если передать переменную по значению, все модификации внутри функции применятся к локальной копии и оставят исходную переменную неизменной.

```go
  incrementCopy := func(i int) {
      i++
  }

  increment := func(i *int) {
      (*i)++
  }

  i := 42

  incrementCopy(i)
  fmt.Println(i) // 42

  increment(&i)
  fmt.Println(i) // 43
```

* Когда нужно подчеркнуть, что значение может отсутствовать. Например, есть функция, которая возвращает запись о пользователе `type User struct{...}` по его идентификатору. Результат-указатель даёт понять, что не по всем идентификаторам может быть найден пользователь. Пример функции с такой сигнатурой:

```go
  func FindUser(id int) *User
```

* Когда вы работаете с ресурсами вроде файловых дескрипторов или сокетов. Копирование таких переменных может быть связано с исчерпанием системных ресурсов или вообще не производиться.

* Когда вы работаете с большими переменными и на копирование по стеку затрачивается больше ресурсов, чем на сборку мусора от указателей.

### Когда не стоит использовать указатели

- Когда хочется ускорить приложение и кажется, что копирование структур — слишком дорогая операция. До тех пор, пока нет тестов, однозначно показывающих, что указатели повышают производительность, лучше не пытаться оптимизировать. Вероятнее всего, напрасно потратите силы или снизите производительность системы, увеличив расходы на сборку мусора.
- Задумываться о замене передачи по значению на передачу по указателю стоит, когда размер структуры достигает порядка сотен байт.
- Когда множество указателей в памяти сильно нагружают сборщик мусора. Такое может произойти, к примеру, при создании собственной in-memory базы данных.

### Передача указателей в качестве аргумета функции

```go
package main

import (
    "fmt"
)

type User struct {
    email    string
    password string
}

// при объявлении указываем,
// что переменная должна быть указателем.
// Для этого ставим звездочку * перед типом данных
func fillUserData(u *User, email string, pass string) {
    u.email = email
    u.password = pass
}

func main() {
    u := User{}

    // передаем указатель с помощью амперсанда
    // & перед переменной
    fillUserData(&u, "test@test.com", "qwerty")

    fmt.Printf("points on func call %+v\n", u)
    // points on func call {email:test@test.com password:qwerty}

    // сразу инициализируем переменную с указателем
    up := &User{}

    fillUserData(up, "test@test.com", "qwerty")

    fmt.Printf("points on init %+v\n", up)
    // points on init {email:test@test.com password:qwerty}
}
```

Мапы по умолчанию передаются с указателем.

[Указатели в Go](https://gobyexample.com/pointers)

[Указатели](http://golang-book.ru/chapter-08-pointers.html)

## Методы структур

В Go нет классов, но существуют структуры с методами. Метод — это функция с дополнительным аргументом, который указывается в скобках между `func` и названием функции:

```go
package main

import (
    "fmt"
)

type Dog struct{}

// сначала объявляется дополнительный аргумент "(d Dog)", а следом идет обычное описание функции
func (d Dog) Bark() {
    fmt.Println("woof!")
}

func main() {
    d := Dog{}
    d.Bark() // woof!
}
```

В примере структура `Dog` передаётся по значенню. Поэтому, при изменении свойст внутри метода `Bark`, исходная структура не имзеняется.

Если изменения необходимы, то нужно передавать указатель:

```go
package main

import (
    "fmt"
)

type Dog struct {
    IsBarked bool
}

func (d *Dog) Bark() {
    fmt.Println("woof!")
    d.IsBarked = true
}

func main() {
    d := &Dog{}
    d.Bark() // woof!

    fmt.Println(d.IsBarked) // true
}
```

## Пользовательские типы

В Go можно объявлять алиас на существующий тип данных. Наример `byte` из модуля строк — это алис `unit8`. Алиас объявляется через `type`:

```go
type NumCount int

func main() {
    nc := NumCount(len([]int{1, 2, 3}))

    fmt.Println(nc) // 3
}
```

Алиас можно конвертировать в исоходный тип и обратно.

```go
type errorCode string

func main() {
    ec := errorCode("internal")

    fmt.Println(ec) // internal

    fmt.Println(string(ec)) // internal
}
```

Также у алиасов могут быть методы. Объявление метода происходит так же, как и со структурами:

```go
type counter int

// передается указатель, чтобы можно было изменить состояние счетчика "c"
func (c *counter) inc() {
    *c++
}

func main() {
    c := counter(0)
    (&c).inc() // передается указатель на счетчик &c, так как функция "inc()" работает с указателями
    (&c).inc()

    fmt.Println(c) // 2
}
```

## Ошибки

Ошибки в Go — это особеность языка, позволяющая работаеть с неожиданым поведением кода в явном виде:

```go
import "errors"

func validateName(name string) error {
    if name == "" {
        // errors.New создает новый объект ошибки
        return errors.New("empty name")
    }

    if len([]rune(name)) > 50 {
        return errors.New("a name cannot be more than 50 characters")
    }

    return nil
}
```

Тип `error` является интерфейсом. Интерфейс — это отдельный тип данных, представляющий набор методов. Любая структура реализует интерфейс неявно через стуктурную типизацию (связывание типа с реализацией во время компиляции без явного указания связи в коде):

```go
package main

import (
    "fmt"
)

// объявление интерфейса
type Printer interface {
    Print()
}

// нигде не указано, что User реализует интерфейс Printer
type User struct {
    email string
}

// структура User имеет метод Print, как в интерфейсе Printer
// Следовательно, во время компиляции запишется связь между User и Printer
func (u *User) Print() {
    fmt.Println("My email is", u.email)
}

// функция принимает как аргумент интерфейс Printer
func TestPrint(p Printer) {
    p.Print()
}

func main() {
    // в функцию TestPrint передается структура User,
    // и так как она реализует интерфейс Printer, все работает без ошибок
    TestPrint(&User{email: "test@test.com"})
}
```

 Интерфейс `error` содержит только один метод `Error`, который возвращет строкое представление ошибки:

```go
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
    Error() string
}
```

можно создавать свои реализации ошибок:

```go
type TimeoutErr struct {
    msg string
}

// структура TimeoutErr реализует интерфейс error
// и может быть использована как обычная ошибка
func (e *TimeoutErr) Error() string {
    return e.msg
}
```

Eсли функция возвращает ошибку, то она всегда возвращается последним аргументом:

```go
// функция возвращает несколько аргументов, и ошибка возвращается последней
func DoHTTPCall(r Request) (Response, error) {
    ...
}
```

Нулевое значение для интерфейса — это пустое значение `nil`, т.е. если ошибок нет, то возвращаетя `nil`.

## Обработка ошибок

Возвращаемые ошибки принято проверять при каждом вызове:

```go
import "log"

response, err := DoHTTPCall()
if err != nil {
    log.Println(err)
}
```

При этом логика обработки ошибки отличается от места и типа ошибки. Ошибки можно оборачивать и прокидывать в функцию выше, логировать или делать любые фоллбек действия.

Оборачивание ошибок — важная часть написения кода на Go. Это позволяет явно видеть трейс вызова и место возникновения ошибки. Для оборачивания используется `fmt.Errorf`:

```go
package main

import (
    "errors"
    "fmt"
)

// для простоты примера опускаем аргументы запроса и ответа
func DoHTTPCall() error {
    err := SendTCP()
    if err != nil {
        // оборачивается в виде "[название метода]: %w". %w — это плейсхолдер для ошибки
        return fmt.Errorf("send tcp: %w", err)
    }

    return nil
}

var errTCPConnectionIssue = errors.New("TCP connect issue")

func SendTCP() error {
    return errTCPConnectionIssue
}

func main() {
    fmt.Println(DoHTTPCall()) // send tcp: TCP connect issue
}
```

Существуют функции для проверки типов конкретных ошибок. Например, ошибку из примера выше можно проверить с промощью функции `errors.Is`. Например, `errTCPConnectionIssue` обёртка для другой ошибки, но `errors.Is` найдёт её при проверке:

```go
err := DoHTTPCall()
if err != nil {
    if errors.Is(err, errTCPConnectionIssue) {
        // в случае ошибки соединения ждем 1 секунду и пытаемся сделать запрос снова
        time.Sleep(1 * time.Second)
        return DoHTTPCall()
    }

    // обработка неизвестной ошибки
    log.Println("unknown error on HTTP call", err)
}
```

`errors.Is` подходит для проверки статических ошибок, хранящихся в переменных. Иногда нужно проверить на конкрентную ошибку, а целый тип. Для этого используется `errors.As`:

```go
package main

import (
    "errors"
    "log"
    "time"
)

// ошибка подключения к базе данных
type ConnectionErr struct{}

func (e ConnectionErr) Error() string {
    return "connection err"
}

func main() {
    // цикл подключения к БД. Пытаемся 3 раза, если не удалось подсоединиться с первого раза.
    tries := 0
    for {
        if tries > 2 {
            log.Println("Can't connect to DB")
            break
        }

        err := connectDB()
        if err != nil {
            // если ошибка подключения, то ждем 1 секунду и пытаемся снова
            if errors.As(err, &ConnectionErr{}) {
                log.Println("Connection error. Trying to reconnect...")
                time.Sleep(1 * time.Second)
                tries++
                continue
            }

            // в противном случае ошибка критичная, логируем и выходим из цикла
            log.Println("connect DB critical error", err)
        }

        break
    }
}

// для простоты функция всегда возвращает ошибку подключения
func connectDB() error {
    return ConnectionErr{}
}
```

Вывод через 3 секунды:

```
Connection error. Trying to reconnect...
Connection error. Trying to reconnect...
Connection error. Trying to reconnect...
Can't connect to DB
```

## Отложенные функции

Есть конструкция `defer`, которая позволяет выполнять функции в фазе выхода из текущей функции:

```go
package main

import (
    "fmt"
)

func main() {
    // функция выполнится в самом конце при выходе из main
    defer fmt.Println("finish")

    fmt.Println("start")
}
```

Вывод:

```go
start
finish
```

Такие функции называются отложенными. Каждая такая функция добавляется в стек отложенных функций и будет выполнена в порядке LIFO (Last In First Out):

```go
package main

import (
    "fmt"
)

func main() {
    defer fmt.Println("3rd")
    defer fmt.Println("2nd")

    fmt.Println("1st")
}
```

Вывод:

```
1st
2nd
3rd
```

Использование отложенных функций распространенно, например для:

* закрытия дескриптора файла после работы;
* возвращение соединения с базой данных в общих пул чтения всех строк;
* закрытие TCP соединения после полного прочтения тела ответа.

## Многопоточность

Современные процессоры (CPU) имеют несколько ядер, и некоторые  поддерживают гиперпоточность, поэтому они могут обрабатывать несколько  инструкций одновременно. Чтобы полностью утилизировать современные CPU,  нужно использовать конкурентное программирование.

Конкурентные вычисления — это форма вычислений, когда несколько  инструкций выполняются, пересекаясь, в течение одного временного  периода.

Например есть 2 инструкции, которые нужно выполнить: `А` и `B`. При выполнении инструкций конкурентно ядро процессора вычисляет инструкцию `A`, при ожидающей `B`. Когда первая инструкция `A` заканчивает активное вычисление, она ставится на паузу, и ядро переключается на вычисление инструкции `B`.

Рассмотрим простой пример конкурентности в реальной жизни: HTTP-запрос к стороннему сервису по сети:

- вычисление `А` делает HTTP-запрос
- пока `А` ждет ответа, начинает выполняться вычисление B
- когда ответ пришел, `А` возвращается в работу

Если в процессоре присутствует более одного ядра, обработка происходит параллельно. Возвращаясь к примеру выше, инструкции `A` и `B` будут выполняться независимо в один момент времени.

Конкурентные вычисления могут происходить в программе, компьютере или сети. В данном курсе рассматривается только уровень программ.

## Горутины

Горутины — легковесные потоки, которые реализуют конкуретное программирование в Go. Они легковесные потому что управляются рантаймом языка, а не операционной системой. Таким образом скорость переключения контекста и расход памяти намного ниже, чем у потоков ОС. Следовательно, для Go — не проблема поддерживать одновременно десятки тысяч горутин.

Для запуска функции в горутине нужно написать слово `go` перед вызвом функции:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // выведет сообщение в горутине
    go fmt.Println("Hello concurrent world")

    // если не подождать, то программа закончится, не успев вывести сообщение
    time.Sleep(100 * time.Millisecond)
}
```

При написании конкурентного кода нужно много чего учитывать: состояние гонки, блокировки, коммуникация между горутинами. Пример программы работающей не так, как ожидается:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Println(i)
        }()
    }

    time.Sleep(100 * time.Millisecond)
}
```

вместо чисел от 0 до 4, будет выведено множество 5, всё потому что `i` передаётся в общем скопе, следовательно, когда горутину будут выполняться цикл уже закончится и `i` будет равно 5. Нужно передавать копию `i`:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func(i int) {
            fmt.Println(i)
        }(i)
    }

    time.Sleep(100 * time.Millisecond)
}
```

Вывод:

```
0
4
3
1
2
```

Также можно заметить, что числа вывелись не в порядке вызова.  Горутины выполняются независимо и не гарантируют порядка. При  необходимости последовательность в выполнении придется реализовывать  самостоятельно.

## Каналы

Для безопасной коммуникации между горутинами используется специальный тип данных: `chan` (канал).

Он инициализируется с пмощью `make`:

```go
numCh := make(chan int)
```

Чтения и запись происходит через `<-`, она ставится перед, если канал читается и после, если записывается:

```go
numCh := make(chan int)

numCh <- 10 // записали значение в канал

num := <- numCh // прочитали значение из канала и записали в переменную "num"
```

Чтения из канала блокируется текущую горутину, пока не вернётся значение:

```go
package main

import (
    "fmt"
)

func main() {
    numCh := make(chan int)

    <-numCh // программа зависнет здесь и будет ошибка: fatal error: all goroutines are asleep - deadlock!

    fmt.Println("program has ended") // эта строка никогда не выведется
}
```

Запись в канал также блокирует текущую гопутину, пока кто-то не прочтёт значение.

Пример использования каналов для задачи с подсчётом суммы слайсов:

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Println(maxSum([]int{1, 2, 3}, []int{10, 20, 50})) // [10 20 50]
}

// суммирует значения каждого слайса nums и возвращает тот, который имеет наибольшую сумму
func maxSum(nums1, nums2 []int) []int {
    // канал для результата первой суммы
    s1Ch := make(chan int)
    go sumParallel(nums1, s1Ch)

    // канал для результата второй суммы
    s2Ch := make(chan int)
    go sumParallel(nums2, s2Ch)

    // присваиваем результаты в переменные. Здесь программа будет заблокирована, пока не придут результаты из обоих каналов.
    s1, s2 := <-s1Ch, <-s2Ch

    if s1 > s2 {
        return nums1
    }

    return nums2
}

func sumParallel(nums []int, resCh chan int) {
    s := 0
    for _, n := range nums {
        s += n
    }

    // результат суммы передаем в канал
    resCh <- s
}
```

Иногда требуется запустить обработчика в отдельной горутине, который будет выполнять работу на протяжении всего цикла жизни программы. С помощью `for range` можно читать из канала до того момента, пока он не будет закрыт:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // создаем канал, в который будем отправлять сообщения
    msgCh := make(chan string)

    // вызываем функцию асинхронно в горутине
    go printer(msgCh)

    msgCh <- "hello"
    msgCh <- "concurrent"
    msgCh <- "world"

    // закрываем канал
    close(msgCh)

    // и ждем, пока printer закончит работу
    time.Sleep(100 * time.Millisecond)
}

func printer(msgCh chan string) {
    // читаем из канала, пока он открыт
    for msg := range msgCh {
        fmt.Println(msg)
    }

    fmt.Println("printer has finished")
}
```

## Область видимости

В Go область видимости можно охарактеризовать двумя параметрами:

- глобальность/локальность;
- экспортируемость/неэкспортируемость.

### Глобальность/локальность

Объявленные в теле функций переменные, константы и функции характеризуются как **локальные**, то есть их область видимости ограничена тем блоком кода, в котором они объявлены. 

В Go локальные переменные можно объявлять ключевым словом `var` или короткой нотацией `:=`. 

Объявленные вне тела функции сущности характеризуются как **глобальные** и находятся в области видимости всех блоков кода в пакете. То есть глобальные объекты доступны во всех файлах, находящихся в одной директории. 

Глобальные переменные нельзя объявлять короткой нотацией `:=`, необходимо ключевое слово `var`. Если глобальная переменная не инициализирована, она принимает нулевое значение указанного типа.

```go
// Глобальные константа и переменные.
const program = "Моё приложение"

var name string
var ver = "v1.0.0" // инициализируем глобальную переменную

func main() {
    // изменяем глобальную переменную name
    name = "Вася"
    fmt.Println("Привет, " + name + "!") // Привет, Вася!
    fmt.Println("Добро пожаловать в", program, ver) // Добро пожаловать в Моё приложение v1.0.0 
} 
```

| Локальные сущности                                           | Глоабльные сущности                           |
| ------------------------------------------------------------ | --------------------------------------------- |
| Объявлены в теле функций                                     | Объявлены вне тела функции                    |
| Область видимости ограничена тем болком кода, в котором они объявлены | Находятся в области всех блоков кода в пакете |
| Можно объявлять ключевым словом `var` или `:=`               | Объявляется только словом `var`               |

### Экспортируемость/неэкспортируемость

Экспортируемость регламентирует доступность из других  пакетов. Пакет в Go — это все файлы c расширением `.go` в одной директории, кроме оканчивающихся на `_test.go`.

> Экспортируемыми могут быть только глобальные сущности.

**Экспортируемые** переменные, константы и функции определённого пакета доступны из тех пакетов, которые импортируют этот пакет ключевым словом `import`. 

Доступ к экспортируемым объектам осуществляется конструкцией `<имя пакета>.<Имя сущности>`:

```go
package main

import "fmt"  // импортируем пакет fmt стандартной библиотеки

func main() {
    fmt.Println("Hello, world!")
} 
```

> Если имя переменной, константы или функции начинается с прописной буквы, то она экспортируемая. Если со строчной, то неэкспортируемая.

К **неэкспортируемым** сущностям нельзя обратиться за пределами пакета.
