# Hello world

```go
// Определение пакета (выполняет роль неймспейсов) main
package main
// Импорт пакета fmt
import "fmt"
// Определение функции main
func main() {
  // Вызов функции Print из пакета fmt
  // Отступ 1 таб
	fmt.Print("Hello, World!")
}
```

Все Go-файлы начинаются с объявления пакета, к которому они относятся.

`main()` — главная функция, выполняемая при запуске любой Go-программы, является точкой входа, не может принимать или возвращать какие-либо аргументы.

После названия пакета распологается блок импорта.

В Go:

* публичные функции пишутся с большой буквы;
* приватные с маленькой.

Для строк в основном используются двойные кавычки `"`.

**Для отступов используются только табы**

## GO

Go — компилируемый и стороготипизируемый язык.

В Go нет исключений. Вместо них используется встроенный интерфейс `error`. Ошибки возвращаются явно последним аргументом из функции. Поэтому Go-код выглядит как череда вызовов функций и проверок на ошибки:

```go 
func main() {
    msg, err := DecodeJSON("")
    if errors.Is(err, errEmptyMessage) {
        // { } empty message
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON("hello")
    if err != nil {
        // { } unmarshal: invalid character 'h' looking for beginning of value
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON(`{"sender":"hexlet","text":"Go,Go,Go"}`)
    // {hexlet Go,Go,Go} <nil>
    fmt.Println(msg, err)
}
```

Самая сильная сторона Go — простое написание конкуретных программ. Для это используются легковесные потоки — горутины. Пример программы суммирующей 10 значений из разных источников:

```go
import (
    "fmt"
    "sync"
)

func main() {
    mu := sync.Mutex{}
    wg := sync.WaitGroup{}

    sum := 0
    for i := 0; i < 10; i++ {
        wg.Add(1)

        // ставим перед любой функцией слово «go», и она выполняется конкурентно в горутине
        go func() {
            // делаем долгий вызов к стороннему API. Так как каждый вызов происходит в своей горутине, мы делаем 10 вызовов одновременно
            n := externalHTTPNum()

            mu.Lock()
            sum += n
            mu.Unlock()

            wg.Done()
        }()
    }

    // ждем, пока все 10 горутин вернут ответ
    wg.Wait()

    fmt.Println(sum) // 55
}
```

## Переменные

Существуют два способа объявления переменных:

* Длинная запись с использованием `var`:

```go
var num int = 10
// или
var num = 10
```

* Короткая запись:

```go
num := 10
```

Изменение значений:

```go
// двоеточие используется только при инициализации
num := 10
num = 20
```

Переменные принято называть в `camelCase`.

Если не завадать значение переменной при инициализации она будет иметь нулевое значение:

```go
var {
  a string // ""
  b bool // false
  c int // 0
}
```

Объявлять переменные можно на уровне функций и пакетов. Прерменные на уровне пакетов будут инициализированны при старте программы. Такие переменные используются не часто. Например, в них можно записывать статические ошибки:

```go
package math

import "errors"

// статичная ошибка
var errCannotSum = errors.New("cannot sum")

func sum(...)
```

В Go принято называть переменные наиболее просто в макимально скоращённом, но доступном для понимания виде:

```go
// плохо
message := ""
buffer := bytes.Buffer{}
// хорошо
msg := ""
buf := bytes.Buffer{}
```

## Функции

Объявляются через ключевое слово `func`:

```go
func multiply(x int, y int) int {
  return x * y
}
```

Здесь:

* `func` — ключевое слово;
* `multiply` — название;
* `(x int, y int)` — входящие аргументы, если несколько аргументов имеет один тип, то можно сократить до `(x, y int)`
* `int` – тип возвращаемого значения

Функции именуются в `camelCase`, если функция именуется с заглавной буквы, то функция экпортируемая (публичная), если с маленькой то доступна только в рамках текущего пакета (приватная).

Функция может возвращать несколько значений, чаще всего это используется для возвращения ошибок:

```go
package math

import "errors"

func divide(x, y int) (int, error) {
    if y == 0 {
        return 0, errors.New("cannot divide on zero")
    }

    return x / y, nil
}
```

Возвращаемые значения можно именовать:

```go
func multiply(x, y int) (res int) {
    res = x * y
    return
}
```

Однако, это сичтается плохой практикой.

При использовании внешней функции нужно указывать имя пакета и через `.` вызываеть публичную функцию.

```go
import "fmt"

func myPrint(msg string) {
    // пакет.функция
    fmt.Println(msg)
}
```

## Числа и операции с ними

В Go есть множество числовых типов данных: uint`, `uint8`, `uint16`, `uint32`, `uint64`, `int`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`, `complex64`, `complex128.

Это нужно для кросплатформенность, в коде достаточно использовать `int` и `unit`, а в момент компиляции они будут преобразованные в необходимые типы для целевой архитектуры.

В основом коде используют:

- `int` — основной кросплатформенный тип целых чисел, может быть отрицательным
- `int64` нужен для больших чисел из внешних систем. Например, ID в СУБД имеет тип `bigint`. Чтобы правильно распарсить такой ID, используется `int64`
- `float64` — число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max()`, определяющая наибольшее число, принимает аргументы в виде `float64`

Стандартные арифметические операции:

```go
x := 10
y := 5

// сложение
x + y // 15
// вычитание
x - y // 5
// деление
x / y // 2
// умножение
x * y // 50
```

Любые операции осуществляются только над числами одного типа.

Чтобы работать с несколькими типа необходимо использовать явное приведения к типу:

```go

x := 5.05
y := 10

x + float64(y)  // 15.05
```

В основом числовые типы конвертируются без проблем между собой, но нужно учитывать некоторые нюансы:

```go
// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer
x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```

## Логические типы

Логичесие типы представлены `true` и `false`, а также операторами:

* `&&` (и)
* `==` (равно)
* `||` (или)
* `!` (не)

Объявление происходит через ключевое слово `bool`:

```go
var b bool = true
bs := false
```

Для проверки не логических типов нужно приводить их к логическим выражениям:

```go
flag := true
text := "hello"

// вариант не сработает, потому что нельзя конвертировать строку в bool
flag && bool(text) // cannot convert text (type string) to type bool

// правильный вариант: если строка не пустая, то в ней есть текст
flag && text != "" // true
```

## Строки

Строки объявляются с типом `string`:

```go
var s string = "hello"

// сокращенная запись
s := "hey"
```

Практически всегда используются довойный ковычки, кроме случая, когда нужно объявить несколько строк, в этом случае используются обратные кавычки:

``` go
q := `
    SELECT *
    FROM person
    WHERE age > 18
`
```

Строки можно сравинивать операторами, строки сравниваются посимвольно в лексическом порядке (по алфавиту) и по длине. Это свойство часто используется при сортировке массива строк:

```go
"привет" == "привет" // true
"golang" > "go" // true
"golang" > "lang" // false
"go" > "foobar" // true
```

Конкатенация осуществляется с помощью `+`.

В Go интерполяция осуществляется черезз функцию `fmt.Sprintf()`:

```go
username := "Ivan"
greetings := fmt.Sprintf("hello, %s", username) // "hello, Ivan"
```

Узнать длину строки можно с помощью встроенной функции `len()`:

```go
len("go") //2
// функция сичитает количество байт, а не реальную длину строки
len("го") // 4
```

## Условные конструкции

Условия представленые конструкцией `if else`. В условии должно быть выражение логического типа:

```go
package main

import (
    "fmt"
    "strings"
)

func statusByName(name string) string {
    // функция проверяет, что строка name начинается с подстроки "Mr."
    if strings.HasPrefix(name, "Mr.") {
        return "married man"
    } else if strings.HasPrefix(name, "Mrs.") {
        return "married woman"
    } else {
        return "single person"
    }
}

func main() {
    n := "Mr. Doe"
    fmt.Println(n + " is a " + statusByName(n)) // Mr. Doe is a married man

    n = "Mrs. Berry"
    fmt.Println(n + " is a " + statusByName(n)) // Mrs. Berry is a married woman

    n = "Karl"
    fmt.Println(n + " is a " + statusByName(n)) // Karl is a single person
}
```

Логическое выражение пишется после `if` без скобок. `else if` можно написать только раздельно.

В Go применяется «ленивая» проверка условий: она идёт слева направо до первого `false` и прекращается, потому что проверять дальше нет смысла. Пример «ленивой» проверки:

```go
a, b := 1, 0

if a == 1 || b == 2 {
    fmt.Println("Hello")
} 
```

В данном примере выполняется левое условие, поэтому проверки (или выполнения) правой части не последует. Пример будет более показателен, если для правой части условия использовать функциональный литерал (подробнее расскажем в теме «Функции»), который будет просто изменять значение переменной `b`.

```go
a, b := 1, 0

incB := func() bool {
    b = b + 1
    return true
}

if a == 1 || incB() {
    fmt.Println("Hello")
}

fmt.Println(a, b) // 1 0 
```

Из-за «ленивой» проверки условий функция `incB` не выполнится — её значение не изменится, то есть функция не изменит значение переменной, потому что выполнение кода прервётся.

Оператор `if` может состоять из двух компонент: инициализации и основного условия. Такая техника позволяет объявлять локальную переменную, которую используют только в рамках области видимости `if`. Это может пригодиться, например, когда нужно преобразовать данные для сравнения. 

```go
a := 0.10000001 // float64
// инициализация и основное условие
if b := float32(a); b > float32(0.1) {
    fmt.Println("Var a is GT float32(0.1)")
} 
```

Условие в данном примере может перестать выполняться, если добавить ещё один ноль: `0.100000001`. Тип `float32` обеспечивает точность в восемь десятичных чисел, в то время как точность `float64` составляет около 15 чисел.

## Switch

Switch по синтаксису схож с реализацией в других языках, но по логике отличается, если в кое-либо условие выполняется, то выполняется блок этого условия и происходит выходит из switch, использание `break` для этого не требуется:

 ```go
 x := 10
 
 switch x {
     default: // default всегда выполняется последним независимо от расположения в конструкции
         fmt.Println("default case")
     case 10:
         fmt.Println("case 10")
 }
 //Output: case 10
 ```

При необоходимости можно реализовать логику, чтобы выполнение не прерывалось, для этого используется `fallthrough`:

```go
x := 10

switch { // выражение отсутствует. Для компилятора выглядит как: switch true
    default:
        fmt.Println("default case")
    case x == 10:
        fmt.Println("equal 10 case")
        fallthrough
    case x <= 10:
        fmt.Println("less or equal 10 case")
}
Output:

equal 10 case
less or equal 10 case
```

**Стоит учитывать, что `fallthrough` переводит выполнение к следующему блоку, даже если выражение в усолвии не выполняется**

Особенности `fallthrough`:

- его можно использовать только в последней строке `case`, иначе будет ошибка компиляции;
- оно игнорирует условие следующего по порядку `case`.

Внутри `switch` можно объявить локальную переменную, доступную только в пределах области видимости оператора:

```go
a := 6
switch b := a % 5; {
case b == 0:
    fmt.Println("Кратно 5")
default:
    fmt.Printf("Остаток от деления на 5: %d", b)
} 
```



## Структуры

В Go нет классов и привычной реализации ООП. Вместо классов используются структуры — наборы полей, Имеющих название и тип данных. Объявление стуктуры имеет следующий вид:

```go
type Person struct {
    // [название поля] [тип данных]
    Name string
    Age int
}

func main() {
    p := Person{Name: "John", Age: 25}

    p.Name // "John"
    p.Age // 25
}
```

Структуру можно инициализировать, не передавая значения. В этом случае каждое поле примет свое «нулевое» значение:

```go
func main() {
    p := Person{}

    p.Name // ""
    p.Age // 0
}
```

Регистр первой буквы в структурах обозначает публичность, так же как в переменных и функциях.

У любого поля структуры можно указать теги. Они используются для  метаинформации о поле для сериализации, валидации, маппинга данных из БД и тд. Тег указывается после типа данных:

```go
type User struct {
    ID int64 `json:"id" validate:"required"`
    Email string `json:"email" validate:"required,email"`
    FirstName string `json:"first_name" validate:"required"`
}
```

Тег `json` используется для названий полей при сериализации/десериализации структуры в json и обратно:

```go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID        int64  `json:"id"`
    Email     string `json:"email"`
    FirstName string `json:"first_name"`
}

func main() {
    u := User{}
    u.ID = 22
    u.Email = "test@test.com"
    u.FirstName = "John"

    bs, _ := json.Marshal(u)

    fmt.Println(string(bs)) // {"id":22,"email":"test@test.com","first_name":"John"}
}
```

Тег `validate` используется Go-валидатором.

```go
package main

import (
    "fmt"
    "github.com/go-playground/validator/v10"
)

type User struct {
    ID        int64  `validate:"required"`
    Email     string `validate:"required,email"`
    FirstName string `validate:"required"`
}

func main() {
    // создали пустую структуру, чтобы проверить валидацию
    u := User{}
    // создаем валидатор
    v := validator.New()
    // метод Struct валидирует переданную структуру и возвращает ошибку `error`, если какое-то поле некорректно
    fmt.Println(v.Struct(u))
}
```

## Константы

Константы объявляются через `const`:

```go
const StatusOk int = 200
```

На практике констакты обычно объявляются так:

```go
const (
    StatusOk = 200
    StatusNotFound = 404
)
```

Для констант допустимы такие типы данных:

* Строки;
* Числа;
* Логические типы;

Регист первой буквы название влияет на уровнь доступа константы.

Константы можно объявлять как не уровне функций, так и пакета:

```go
package main

import "fmt"

const defaultStatus = 200

func main() {
    const status = 404

    fmt.Println("default status:", defaultStatus) // default status: 200
    fmt.Println("current status:", status) // current status: 404
}
```

Именнованные константы могут быть разного типа, тип связан с хранимым значением.

```go
const intConst = 5 
const floatConst = 5.0
const runeConst = 'A'
const strConst = "Hello, world!"
const boolConst = true 
```

Может показаться, что если опустить тип при объявлении константы, то компилятор выберет его сам — как в случае с короткой формой объявления переменных. Это так лишь отчасти. В случае с константами отсутствие явного указания типа имеет большее значение.

Например, если вы объявляете константу `intConst` и присваиваете ей значение `5`, то получаете **целочисленную константу с неопределённым типом** (`untyped int`). Конкретный тип значения этой константы ещё не определён и в разных контекстах будет интерпретироваться компилятором по-разному. Это позволяет ослабить типизацию для констант, не отказываясь от сильной типизации глобально.

Благодаря этому подходу будет работать следующий пример:

```go
package main

import (
    "fmt"
)

const id = 100

func main() {
    var i int64 = id
    var f float64 = id

    fmt.Println("i=", i, "f=", f) // i = 100 f = 100 
} 
```

Если в группе констанкт не указано значение, то оно будет равно значению предыдущей константы:

```go
const (
    pi = 3.1415
    e
    name = "John Doe"
    fullName
)

func main() {
    fmt.Println("pi =", pi, "e =", e) // pi = 3.1415 e = 3.1415
    fmt.Println("name =", name, "fullName =", fullName) // name = John Doe fullName = John Doe
}
```

### `iota`

Для последовательных числовых констант следует использовать идентификатор `iota`, который присвоит для списка чисел значения от его текущей позиции:

```go
package main

import "fmt"

const (
    zero = iota
    one
    two
    three
)

const (
	a = iota
	b = 42
	c = iota
	d
)

func main() {
	fmt.Println(zero, one, two, three) // 0 1 2 3
	fmt.Println(a, b, c, d)            // 0, 42, 2, 3
}
```

`iota` можно также использовать в арифметических выражениях, чтобы быстро объявить ряд значений с прогрессией. Следует помнить, что `iota` увеличивается на единицу для каждой строки, где указано имя константы, даже если той было присвоено конкретное значение.

```go
const (
    _ = iota*10  // обратите внимание, что можно пропускать константы 
    ten
    twenty
    thirty
)

const (
    hello = "Hello, world!"  // iota равна 0
    one = 1                  // iota равна 1

    black = iota   // iota равна 2
    gray
)

func main() {
    fmt.Println(ten, twenty, thirty) // 10 20 30
    fmt.Println(black, gray) // 2 3
}
```

### Пользовательские типы констант

Предположим, нужно определить константы для дней недели. 

```go
const (
    Monday = iota + 1
    Tuesday
    //...
    Sunday
) 
```

Если перечислить их так, то все константы будут иметь нетипизированный числовой тип и могут использоваться в любых выражениях, что может вносить путаницу: `var i int = Monday + 1`. В подобных случаях стоит определить пользовательский тип и указать его при определении констант.

```go
type Weekday int

const (
    Monday Weekday = iota + 1
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    Sunday
)

func NextDay(day Weekday) Weekday {
    return (day % 7) + 1
}

func main() {
    var today Weekday = Sunday
    tomorrow := NextDay(today)
    fmt.Println("today =", today, "tomorrow =", tomorrow) // today = 7 tomorrow = 1 
} 
```

## Литералы

В Go можно использовать различные представления строковых и числовых литералов. Проиллюстрируем на примере целого числа `1000`:

```go
1000
1000.0
1_000 // можно разделять части числа символом '_' для удобства восприятия
01750 // восьмеричное представление, начинается с 0
0x3e8 // шестнадцатеричное представление
0b001111101000 // бинарное представление 
```

Любой из этих литералов может быть использован в выражениях и даст одно и то же значение. 

## Массивы

Массив — коллекция однотипных значений, фиксированной длины:

```go
nums := [5]int{}
```

Длина массива указвается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:

```go
nums := [5]int{} // [0, 0, 0, 0, 0]
// длинная инициализация
var nums [5]int // [0, 0, 0, 0, 0]
```

При попытке инициализации элементов за границей массива выходит ошибка компиляции:

```go
nums := [1]int{1,2} 
```

Чтение и запись происходит через квадратные скобки:

```go
nums := [3]int{1, 2, 3}
fmt.Println(nums[1]) // 2

nums[2] = 33
fmt.Println(nums) // [1, 2, 33]
```

Нумерация элементов массива начинается с 0, при попытке чтения за границей будет ошибка компиляции.

Массивы передаются по значению — т.е. лебое изменение внутри функции не виляет на исходный массив.

В Go есть встроенная функция `len()`, которая возвращает длину массива:

```go
fmt.Println(len([5]int{1,2,3})) // 5
fmt.Println(len([10]int{})) // 10
```

Так как массивы инициализируются с фиксированной длинной, то функция `len()` всегда возвращает одно и то же значение.

## Слайсы

Слайсы — массив неопределённой длины (или динамический массив):

```go
var nums = []int{1,2,3}

nums := []int{1,2,3}
```

Чтение и запись осуществляется так же как в массиве:

```go
nums := []int{1,2,3}
nums[2] // 3
nums[0] = 10 // [10, 2, 3]
// с помощью оператора : можно получить элементы от нижней до верхней границы
nums[1:3] // [2, 3]
nums[:2] // [10, 2]
nums[2:] // [3]
```

В слайсы можно добавить элементы с помощью встроенной функции `append`:

```go
words := []string{"hello"}

words = append(words, "world") // ["hello", "world"]
```

Внутри себя слайс, помимо самих элементов, хранит 2 дополнительных свойства: длину массива (`len`) и вместимость массива ( `cap`). Благодаря этому можно инциализровать слайс нужной длины с помощью функции `make`:

```go
// len = 5. Массив сразу будет заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5. Массив будет пустым, однако заполнение слайса через append будет эффективным, потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
```

Передача слайса в качестве аргумета функции происходит так: длина и вместимость передаются по значению, но массив значений передаётся по ссылке, таким образом выходит, что добавление элементов не сохраняется в исходный слайд, но изменение остаются:

```go
package main

import (
    "fmt"
)

func main() {
    nums := []int{1, 2, 3, 4, 5}

    modifySlice(nums)

    fmt.Println(nums) // [1 2 10 4 5]
}

func modifySlice(nums []int) {
    nums[2] = 10 // элемент будет и в исходном слайсе
    nums = append(nums, 6) // элемент не добавится в исходный слайс
}
```

Для слайсов можно распаковывать значение с помощью `...`:

```go
nums := []int{1, 2, 3, 4, 5}
nums[]...
```

## Цикл for

Обход коллекций осуществляется только через цикл `for`:

```go
nums := make([]int, 0, 10)

// начиная с 0; пока i меньше 10; инкрементим i после каждого шага
for i := 0; i < 10; i++ {
    nums = append(nums, i)
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

При необходимости `for` используется как `while`:

```go
i := 0
nums := make([]int, 0, 10)

for i < 10 {
    nums = append(nums, i)
    i++
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Если опучстить условие, то можно уйти в бесконечный цикл.

Если условное выражение возвращает `false` или был вызыван `break` в теле цикла, то происходит остановка цикла. Для перехода к следующей итерации используется `continue`:

```go
nums := make([]int, 0, 10)

// добавляем только четные числа в слайс
for i := 0; i < 10; i++ {
    if i % 2 != 0 {
        continue
    }

    nums = append(nums, i)
}

fmt.Println(nums) // [0 2 4 6 8]
```

Для обхода коллекции есть `range`:

```go
names := []string{"John", "Harold", "Vince"}

// i — это индекс, name — это значение на текущем шаге цикла
for i, name := range names {
    fmt.Println("Hello ", name, " at index ", i)
}
```

## Копирование слайсов

Функция `copy(dst, src []Type) int` копирует слайс `src` в слайс `dst` и возвращает колиечство скопированных элементов:

```go
nums := []int{1,2,3,4,5}

// важно инициализировать слайс той же длины
numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp) // [1,2,3,4,5]
```

При копировании выжно соответствие длины слайсов, если если элементы будут выходить за длину `dst` то они не будут скопированны:

```go
nums := []int{1, 2, 3, 4, 5}

// создали слайс с длиной 0
numsCp := make([]int, 0)

// при копировании в пустой слайс ничего не произойдет
copy(numsCp, nums)

fmt.Println(numsCp) // []
```

## Сортировка слайсов

Стандартный пакет `sort` предоставляет функции для сортировки:

```go
nums := []int{2,1,6,5,3,4}

sort.Slice(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Рассмотрим функцию `Slice(x interface{}, less func(i, j int) bool)`. Следует запомнить, что пустой интерфейс `interface{}` в Go означает тип данных, под который подходит любой другой тип.

В функцию `Slice(x interface{}, less func(i, j int) bool)`  передается слайс любого типа данных, как первый аргумент. Вторым  аргументом передается функция, которая берет элементы по индексу и  определяет должен ли элемент по индексу `i` находиться перед элементом по индексу `j`.

Внутри функции **sort.Slice** используется быстрая сортировка. В пакете также присутствует сортировка вставками `sort.SliceStable`:

```go
nums := []int{2,1,6,5,3,4}

sort.SliceStable(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Выбор алгоритма зависит от набора и размера данных, архитектуры  процессора, скорости доступа к памяти, то есть от многих факторов. Для  большинства стандартных случаев используется `sort.Slice`

## Мап

Map — тип данных, предназначеный для хранения пар ключ-знамения (в других языках: хэш-таблица, словарь, асоциативный массив):

```go
// создание пустой мапы
var m map[int]string

// сокращенное создание пустой мапы
m := map[int]string{}

// рекомендуемое создание с обозначением размера
m := make(map[int]string, 10)

// создание мапы с элементами
m := map[int]string{1: "hello", 2: "world"}

// добавление элемента
m[3] = "!" // map[1:hello, 2:world, 3:!]

// чтение элемента
word := m[1] // "hello"
```

При чтении элемента по несуществующему ключу возвращается нулевое значение типа. При использовании bool как значения это приводит к ошибкам логики, для решения этого используется вторая переменная, в которую записывается наличие жлемента в мапе:

```go
elements := map[int64]bool{1: true, 2: false}

element, elementExists := elements[1] // true, true
element, elementExists := elements[2] // false, true
element, elementExists := elements[225] // false, false

// пустая структура struct{} — это тип данных, который занимает 0 байт
// используется, когда нужно проверять в мапе только наличие ключа
cache := make(map[string]struct{})

// проверяем есть ли ключ `key` в мапе
_, ok = cache["key"]
fmt.Println(ok)  // false

// добавим ключ и проверим вновь
cache["key"] = struct{}{}
_, ok = cache["key"]
fmt.Println(ok)  // true

```

Элементы удаляются с помощью функции `delete(m map[Type]Type1, key Type)`:

```go
engToRus := map[string]string{"hello":"привет", "world":"мир"}

delete(engToRus, "world")

fmt.Println(engToRus) // map[hello:привет]
```

Мапы всегда передаются по ссылке

## Обход мап

Как и слайс, мапу можно обойти с помощью `for range`:

```go
idToName := map[int64]string{1: "Alex", 2: "Dan", 3: "George"}

// первый аргумент — ключ, второй — значение
for id, name := range idToName {
    fmt.Println("id: ", id, "name: ", name)
}
```

Стоит учитывать, что порядок ключей в мапе рандомизирован.

## Строки и байты

Строки в Go — это иммутабельные массивы байт. Для стандартного компилятора Go внутренняя структура строки описана как:

```go
type _string struct {
    elements *byte // байты
    len      int   // кол-во байт
}
```

После инициализации строку нельзя изменить и такая иммутабельность позволяет избежать побочных эффектов в коде.

```go
s := "hello"
s[4] = "" // ошибка компиляции: cannot assign to s[4] (strings are immutable)
```

Стоит отметить, что тип данных `byte` — это алиас к типу `uint8` (0-255). Во-первых, потому что нужно абстрактно отличать типы в коде.  Во-вторых, байты представляют ASCII символы, а в кодовой таблице ASCII  символов 256 кодов:

```go
package main

import "fmt"

func main() {
    s := "hey"

    fmt.Println(s[0], s[1], s[2]) // 104 101 121

    fmt.Println(string(s[0]), string(s[1]), string(s[2])) // h e y
}
```

Большинство библиотечных функций работают со слайсами байт `[]byte` для производительности. Конвертация строки в слайс байт описывается в коде явно:

```go
package main

import "fmt"

func main() {
    s := "hey"
    bs := []byte(s)

    fmt.Println([]byte(s)) // [104 101 121]

    fmt.Println(string(bs)) // hey
}
```

Отдельные ASCII символы можно объявлять сразу с типом `byte`. Для этого нужно обернуть символ в одинарные кавычки и указать тип `byte`:

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    asciiCh := byte('Q')
    asciiChStr := string(asciiCh)

    fmt.Println(reflect.TypeOf(asciiCh), asciiCh) // uint8 90

    fmt.Println(reflect.TypeOf(asciiChStr), asciiChStr) // string Q
}
```

## Обход строки

Строки можно обходить с помощью `for`:

```go
package main

import (
    "fmt"
)

func main() {
    s := "hello"
    for i := 0; i < len(s); i++ {
        fmt.Println(string(s[i]))
    }

}
```

Однако, это корректно будет работать только со строками из ASCII символов, при работе с многобайтовыми строка вывод будет некорректным.

## Руны

Для работы с юникод-символами в Go есть тип `rune`:

```go
package main

import (
    "fmt"
)

func main() {
    emoji := []rune("привет😀")

    for i := 0; i < len(emoji); i++ {
        fmt.Println(emoji[i], string(emoji[i])) // выводим код символа и его строковое представление
    }
}
```

`rune` — алиас к `int32`. Как и байты, руны были созданы для отличия от встроенного типа данных. Каждая рунна — это код символа Юникода. Строка преобразуется в `byte[]` и `rune[]`, но между собой эти два типа не конвертируются напрямую.

В Go присутствует синтаксический сахар при обходе строки. Если использовать конструкцию `for range`, строка автоматически будет преобразована в `[]rune`, то есть обход будет по Юникод символам:

```go
package main

import (
    "fmt"
)

func main() {
    emoji := []rune("cool😀")

    for _, ch := range emoji {
        fmt.Println(ch, string(ch)) // выводим код символа и его строковое представление
    }
}
```

## Стандартный пакет strings

Для работы со строками существует пакет `strings`, который содержит основные функции. Например часто используются функции:

```go
import "strings"

// проверяет наличие подстроки в строке
strings.Contains("hello", "h") // true

// разбивает строку по Юникод символам или по переданному разделителю
strings.Split("hello", "") // ["h", "e", "l", "l", "o"]

// склеивает строки из слайса с разделителем
strings.Join([]string{"hello","world!"}, " ") // "hello world!"
```

Важная часть этого пакета —это `Builder`. Когда необходимо собрать большую строку по каким-то правилам лучше не использовать конкатенацию, а использовать `Builder`:

```go
import "strings"

sb := strings.Builder{}

sb.st("hello")
sb.WriteString(" ")
sb.WriteString("world")

sb.String() // "hello world"
```

[Пакет strings](https://pkg.go.dev/strings)

## Форматирование строк

Пакет `fmt` используется не только для вывода переменных или реультатов функций, но и для форматирования строк. Для подстановки значений используются плейсхолдеры:

```go
name := "Andy"

// подставляем строку
fmt.Sprintf("hello %s", name) // "hello Andy"

// число
fmt.Sprintf("there are %d kittens", 10) // "there are 10 kittens"

// логический тип
fmt.Sprintf("your story is %t", true) // "your story is true"
```

Также существуют специализированные плейсхолдеры, которые преобразуют сложные структуры:

```go
package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Andy", Age: 18}

    // вывод значений структуры
  	// simple struct: {Andy 18}
    fmt.Println("simple struct:", p)

    // вывод названий полей и их значений
  	// detailed struct: {Name:Andy Age:18}
    fmt.Printf("detailed struct: %+v\n", p)

    // вывод названий полей и их значений в виде инициализации
  	// Golang struct: main.Person{Name:"Andy", Age:18}
    fmt.Printf("Golang struct: %#v\n", p)
}
```

[Пакет fmt](https://pkg.go.dev/fmt)

## Вариативные функции

Последний аргумент функции может быть вариативным. Функция может иметь маскимум один вариативный агрумент и этот агрумент всегда слайс. Чтобы обозначить аргумент вариативным нужно поставить `…` перед его типом:

```go
package main

import (
    "fmt"
)

func main() {
    // кол-во аргументов может быть любым
    PrintNums(1, 2, 3)
}


func PrintNums(nums ...int) {
    for _, n := range nums {
        fmt.Println(n)
    }
}
```

Также `…` можно разбить слайс на элементы при предаче в вариативную функцию. Например, метод `append(slice []Type, elems …Type) []Type` принимает вариативный аргумент `elems …Type`. Чтобы добавить один слайс в конец другого, нужно разить второй слайс на элементы путем добавления  `…` после переменной:

```go
nums1 := []int{1,2,3,4,5}
nums2 := []int{6,7,8,9,10}

res := append(nums1, nums2...) // [1 2 3 4 5 6 7 8 9 10]
```

## Передача указателей в качестве аргумета функции

```go
package main

import (
    "fmt"
)

type User struct {
    email    string
    password string
}

// при объявлении указываем,
// что переменная должна быть указателем.
// Для этого ставим звездочку * перед типом данных
func fillUserData(u *User, email string, pass string) {
    u.email = email
    u.password = pass
}

func main() {
    u := User{}

    // передаем указатель с помощью амперсанда
    // & перед переменной
    fillUserData(&u, "test@test.com", "qwerty")

    fmt.Printf("points on func call %+v\n", u)
    // points on func call {email:test@test.com password:qwerty}

    // сразу инициализируем переменную с указателем
    up := &User{}

    fillUserData(up, "test@test.com", "qwerty")

    fmt.Printf("points on init %+v\n", up)
    // points on init {email:test@test.com password:qwerty}
}
```

Мапы по умолчанию передаются с указателем.

[Указатели в Go](https://gobyexample.com/pointers)

[Указатели](http://golang-book.ru/chapter-08-pointers.html)

## Методы структур

В Go нет классов, но существуют структуры с методами. Метод — это функция с дополнительным аргументом, который указывается в скобках между `func` и названием функции:

```go
package main

import (
    "fmt"
)

type Dog struct{}

// сначала объявляется дополнительный аргумент "(d Dog)", а следом идет обычное описание функции
func (d Dog) Bark() {
    fmt.Println("woof!")
}

func main() {
    d := Dog{}
    d.Bark() // woof!
}
```

В примере структура `Dog` передаётся по значенню. Поэтому, при изменении свойст внутри метода `Bark`, исходная структура не имзеняется.

Если изменения необходимы, то нужно передавать указатель:

```go
package main

import (
    "fmt"
)

type Dog struct {
    IsBarked bool
}

func (d *Dog) Bark() {
    fmt.Println("woof!")
    d.IsBarked = true
}

func main() {
    d := &Dog{}
    d.Bark() // woof!

    fmt.Println(d.IsBarked) // true
}
```

## Пользовательские типы

В Go можно объявлять алиас на существующий тип данных. Наример `byte` из модуля строк — это алис `unit8`. Алиас объявляется через `type`:

```go
type NumCount int

func main() {
    nc := NumCount(len([]int{1, 2, 3}))

    fmt.Println(nc) // 3
}
```

Алиас можно конвертировать в исоходный тип и обратно.

```go
type errorCode string

func main() {
    ec := errorCode("internal")

    fmt.Println(ec) // internal

    fmt.Println(string(ec)) // internal
}
```

Также у алиасов могут быть методы. Объявление метода происходит так же, как и со структурами:

```go
type counter int

// передается указатель, чтобы можно было изменить состояние счетчика "c"
func (c *counter) inc() {
    *c++
}

func main() {
    c := counter(0)
    (&c).inc() // передается указатель на счетчик &c, так как функция "inc()" работает с указателями
    (&c).inc()

    fmt.Println(c) // 2
}
```

## Ошибки

Ошибки в Go — это особеность языка, позволяющая работаеть с неожиданым поведением кода в явном виде:

```go
import "errors"

func validateName(name string) error {
    if name == "" {
        // errors.New создает новый объект ошибки
        return errors.New("empty name")
    }

    if len([]rune(name)) > 50 {
        return errors.New("a name cannot be more than 50 characters")
    }

    return nil
}
```

Тип `error` является интерфейсом. Интерфейс — это отдельный тип данных, представляющий набор методов. Любая структура реализует интерфейс неявно через стуктурную типизацию (связывание типа с реализацией во время компиляции без явного указания связи в коде):

```go
package main

import (
    "fmt"
)

// объявление интерфейса
type Printer interface {
    Print()
}

// нигде не указано, что User реализует интерфейс Printer
type User struct {
    email string
}

// структура User имеет метод Print, как в интерфейсе Printer
// Следовательно, во время компиляции запишется связь между User и Printer
func (u *User) Print() {
    fmt.Println("My email is", u.email)
}

// функция принимает как аргумент интерфейс Printer
func TestPrint(p Printer) {
    p.Print()
}

func main() {
    // в функцию TestPrint передается структура User,
    // и так как она реализует интерфейс Printer, все работает без ошибок
    TestPrint(&User{email: "test@test.com"})
}
```

 Интерфейс `error` содержит только один метод `Error`, который возвращет строкое представление ошибки:

```go
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
    Error() string
}
```

можно создавать свои реализации ошибок:

```go
type TimeoutErr struct {
    msg string
}

// структура TimeoutErr реализует интерфейс error
// и может быть использована как обычная ошибка
func (e *TimeoutErr) Error() string {
    return e.msg
}
```

Eсли функция возвращает ошибку, то она всегда возвращается последним аргументом:

```go
// функция возвращает несколько аргументов, и ошибка возвращается последней
func DoHTTPCall(r Request) (Response, error) {
    ...
}
```

Нулевое значение для интерфейса — это пустое значение `nil`, т.е. если ошибок нет, то возвращаетя `nil`.

## Обработка ошибок

Возвращаемые ошибки принято проверять при каждом вызове:

```go
import "log"

response, err := DoHTTPCall()
if err != nil {
    log.Println(err)
}
```

При этом логика обработки ошибки отличается от места и типа ошибки. Ошибки можно оборачивать и прокидывать в функцию выше, логировать или делать любые фоллбек действия.

Оборачивание ошибок — важная часть написения кода на Go. Это позволяет явно видеть трейс вызова и место возникновения ошибки. Для оборачивания используется `fmt.Errorf`:

```go
package main

import (
    "errors"
    "fmt"
)

// для простоты примера опускаем аргументы запроса и ответа
func DoHTTPCall() error {
    err := SendTCP()
    if err != nil {
        // оборачивается в виде "[название метода]: %w". %w — это плейсхолдер для ошибки
        return fmt.Errorf("send tcp: %w", err)
    }

    return nil
}

var errTCPConnectionIssue = errors.New("TCP connect issue")

func SendTCP() error {
    return errTCPConnectionIssue
}

func main() {
    fmt.Println(DoHTTPCall()) // send tcp: TCP connect issue
}
```

Существуют функции для проверки типов конкретных ошибок. Например, ошибку из примера выше можно проверить с промощью функции `errors.Is`. Например, `errTCPConnectionIssue` обёртка для другой ошибки, но `errors.Is` найдёт её при проверке:

```go
err := DoHTTPCall()
if err != nil {
    if errors.Is(err, errTCPConnectionIssue) {
        // в случае ошибки соединения ждем 1 секунду и пытаемся сделать запрос снова
        time.Sleep(1 * time.Second)
        return DoHTTPCall()
    }

    // обработка неизвестной ошибки
    log.Println("unknown error on HTTP call", err)
}
```

`errors.Is` подходит для проверки статических ошибок, хранящихся в переменных. Иногда нужно проверить на конкрентную ошибку, а целый тип. Для этого используется `errors.As`:

```go
package main

import (
    "errors"
    "log"
    "time"
)

// ошибка подключения к базе данных
type ConnectionErr struct{}

func (e ConnectionErr) Error() string {
    return "connection err"
}

func main() {
    // цикл подключения к БД. Пытаемся 3 раза, если не удалось подсоединиться с первого раза.
    tries := 0
    for {
        if tries > 2 {
            log.Println("Can't connect to DB")
            break
        }

        err := connectDB()
        if err != nil {
            // если ошибка подключения, то ждем 1 секунду и пытаемся снова
            if errors.As(err, &ConnectionErr{}) {
                log.Println("Connection error. Trying to reconnect...")
                time.Sleep(1 * time.Second)
                tries++
                continue
            }

            // в противном случае ошибка критичная, логируем и выходим из цикла
            log.Println("connect DB critical error", err)
        }

        break
    }
}

// для простоты функция всегда возвращает ошибку подключения
func connectDB() error {
    return ConnectionErr{}
}
```

Вывод через 3 секунды:

```
Connection error. Trying to reconnect...
Connection error. Trying to reconnect...
Connection error. Trying to reconnect...
Can't connect to DB
```

## Отложенные функции

Есть конструкция `defer`, которая позволяет выполнять функции в фазе выхода из текущей функции:

```go
package main

import (
    "fmt"
)

func main() {
    // функция выполнится в самом конце при выходе из main
    defer fmt.Println("finish")

    fmt.Println("start")
}
```

Вывод:

```go
start
finish
```

Такие функции называются отложенными. Каждая такая функция добавляется в стек отложенных функций и будет выполнена в порядке LIFO (Last In First Out):

```go
package main

import (
    "fmt"
)

func main() {
    defer fmt.Println("3rd")
    defer fmt.Println("2nd")

    fmt.Println("1st")
}
```

Вывод:

```
1st
2nd
3rd
```

Использование отложенных функций распространенно, например для:

* закрытия дескриптора файла после работы;
* возвращение соединения с базой данных в общих пул чтения всех строк;
* закрытие TCP соединения после полного прочтения тела ответа.

## Многопоточность

Современные процессоры (CPU) имеют несколько ядер, и некоторые  поддерживают гиперпоточность, поэтому они могут обрабатывать несколько  инструкций одновременно. Чтобы полностью утилизировать современные CPU,  нужно использовать конкурентное программирование.

Конкурентные вычисления — это форма вычислений, когда несколько  инструкций выполняются, пересекаясь, в течение одного временного  периода.

Например есть 2 инструкции, которые нужно выполнить: `А` и `B`. При выполнении инструкций конкурентно ядро процессора вычисляет инструкцию `A`, при ожидающей `B`. Когда первая инструкция `A` заканчивает активное вычисление, она ставится на паузу, и ядро переключается на вычисление инструкции `B`.

Рассмотрим простой пример конкурентности в реальной жизни: HTTP-запрос к стороннему сервису по сети:

- вычисление `А` делает HTTP-запрос
- пока `А` ждет ответа, начинает выполняться вычисление B
- когда ответ пришел, `А` возвращается в работу

Если в процессоре присутствует более одного ядра, обработка происходит параллельно. Возвращаясь к примеру выше, инструкции `A` и `B` будут выполняться независимо в один момент времени.

Конкурентные вычисления могут происходить в программе, компьютере или сети. В данном курсе рассматривается только уровень программ.

## Горутины

Горутины — легковесные потоки, которые реализуют конкуретное программирование в Go. Они легковесные потому что управляются рантаймом языка, а не операционной системой. Таким образом скорость переключения контекста и расход памяти намного ниже, чем у потоков ОС. Следовательно, для Go — не проблема поддерживать одновременно десятки тысяч горутин.

Для запуска функции в горутине нужно написать слово `go` перед вызвом функции:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // выведет сообщение в горутине
    go fmt.Println("Hello concurrent world")

    // если не подождать, то программа закончится, не успев вывести сообщение
    time.Sleep(100 * time.Millisecond)
}
```

При написании конкурентного кода нужно много чего учитывать: состояние гонки, блокировки, коммуникация между горутинами. Пример программы работающей не так, как ожидается:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Println(i)
        }()
    }

    time.Sleep(100 * time.Millisecond)
}
```

вместо чисел от 0 до 4, будет выведено множество 5, всё потому что `i` передаётся в общем скопе, следовательно, когда горутину будут выполняться цикл уже закончится и `i` будет равно 5. Нужно передавать копию `i`:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func(i int) {
            fmt.Println(i)
        }(i)
    }

    time.Sleep(100 * time.Millisecond)
}
```

Вывод:

```
0
4
3
1
2
```

Также можно заметить, что числа вывелись не в порядке вызова.  Горутины выполняются независимо и не гарантируют порядка. При  необходимости последовательность в выполнении придется реализовывать  самостоятельно.

## Каналы

Для безопасной коммуникации между горутинами используется специальный тип данных: `chan` (канал).

Он инициализируется с пмощью `make`:

```go
numCh := make(chan int)
```

Чтения и запись происходит через `<-`, она ставится перед, если канал читается и после, если записывается:

```go
numCh := make(chan int)

numCh <- 10 // записали значение в канал

num := <- numCh // прочитали значение из канала и записали в переменную "num"
```

Чтения из канала блокируется текущую горутину, пока не вернётся значение:

```go
package main

import (
    "fmt"
)

func main() {
    numCh := make(chan int)

    <-numCh // программа зависнет здесь и будет ошибка: fatal error: all goroutines are asleep - deadlock!

    fmt.Println("program has ended") // эта строка никогда не выведется
}
```

Запись в канал также блокирует текущую гопутину, пока кто-то не прочтёт значение.

Пример использования каналов для задачи с подсчётом суммы слайсов:

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Println(maxSum([]int{1, 2, 3}, []int{10, 20, 50})) // [10 20 50]
}

// суммирует значения каждого слайса nums и возвращает тот, который имеет наибольшую сумму
func maxSum(nums1, nums2 []int) []int {
    // канал для результата первой суммы
    s1Ch := make(chan int)
    go sumParallel(nums1, s1Ch)

    // канал для результата второй суммы
    s2Ch := make(chan int)
    go sumParallel(nums2, s2Ch)

    // присваиваем результаты в переменные. Здесь программа будет заблокирована, пока не придут результаты из обоих каналов.
    s1, s2 := <-s1Ch, <-s2Ch

    if s1 > s2 {
        return nums1
    }

    return nums2
}

func sumParallel(nums []int, resCh chan int) {
    s := 0
    for _, n := range nums {
        s += n
    }

    // результат суммы передаем в канал
    resCh <- s
}
```

Иногда требуется запустить обработчика в отдельной горутине, который будет выполнять работу на протяжении всего цикла жизни программы. С помощью `for range` можно читать из канала до того момента, пока он не будет закрыт:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // создаем канал, в который будем отправлять сообщения
    msgCh := make(chan string)

    // вызываем функцию асинхронно в горутине
    go printer(msgCh)

    msgCh <- "hello"
    msgCh <- "concurrent"
    msgCh <- "world"

    // закрываем канал
    close(msgCh)

    // и ждем, пока printer закончит работу
    time.Sleep(100 * time.Millisecond)
}

func printer(msgCh chan string) {
    // читаем из канала, пока он открыт
    for msg := range msgCh {
        fmt.Println(msg)
    }

    fmt.Println("printer has finished")
}
```

## Область видимости

В Go область видимости можно охарактеризовать двумя параметрами:

- глобальность/локальность;
- экспортируемость/неэкспортируемость.

### Глобальность/локальность

Объявленные в теле функций переменные, константы и функции характеризуются как **локальные**, то есть их область видимости ограничена тем блоком кода, в котором они объявлены. 

В Go локальные переменные можно объявлять ключевым словом `var` или короткой нотацией `:=`. 

Объявленные вне тела функции сущности характеризуются как **глобальные** и находятся в области видимости всех блоков кода в пакете. То есть глобальные объекты доступны во всех файлах, находящихся в одной директории. 

Глобальные переменные нельзя объявлять короткой нотацией `:=`, необходимо ключевое слово `var`. Если глобальная переменная не инициализирована, она принимает нулевое значение указанного типа.

```go
// Глобальные константа и переменные.
const program = "Моё приложение"

var name string
var ver = "v1.0.0" // инициализируем глобальную переменную

func main() {
    // изменяем глобальную переменную name
    name = "Вася"
    fmt.Println("Привет, " + name + "!") // Привет, Вася!
    fmt.Println("Добро пожаловать в", program, ver) // Добро пожаловать в Моё приложение v1.0.0 
} 
```

| Локальные сущности                                           | Глоабльные сущности                           |
| ------------------------------------------------------------ | --------------------------------------------- |
| Объявлены в теле функций                                     | Объявлены вне тела функции                    |
| Область видимости ограничена тем болком кода, в котором они объявлены | Находятся в области всех блоков кода в пакете |
| Можно объявлять ключевым словом `var` или `:=`               | Объявляется только словом `var`               |

### Экспортируемость/неэкспортируемость

Экспортируемость регламентирует доступность из других  пакетов. Пакет в Go — это все файлы c расширением `.go` в одной директории, кроме оканчивающихся на `_test.go`.

> Экспортируемыми могут быть только глобальные сущности.

**Экспортируемые** переменные, константы и функции определённого пакета доступны из тех пакетов, которые импортируют этот пакет ключевым словом `import`. 

Доступ к экспортируемым объектам осуществляется конструкцией `<имя пакета>.<Имя сущности>`:

```go
package main

import "fmt"  // импортируем пакет fmt стандартной библиотеки

func main() {
    fmt.Println("Hello, world!")
} 
```

> Если имя переменной, константы или функции начинается с прописной буквы, то она экспортируемая. Если со строчной, то неэкспортируемая.

К **неэкспортируемым** сущностям нельзя обратиться за пределами пакета.
