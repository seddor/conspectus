# Настройка окружения

## Компиляция и запуск файлов

Запустить программу на Go можно двумя способами:

* `go run` — комманда компилирует Go файл, запускает его и удаляет;
* `go build` — команда компилирует файл и создаёт испольняемый файл в текущей директории.

## Кроссплатформенность

В Go есть команды, с помощью которых можно быстро скомпилировать файлы  под разные операционные системы. Чтобы создать исполняемый файл, нужно  указать правильные переменные окружения:

```bash
go mod init hello # Создаем Go-модуль

GOOS=windows GOARCH=386 go build -o hello_windows.exe # Исполняемый файл для Windows

GOOS=windows GOARCH=amd64 go build -o hello_windows64.exe # Файл для Windows с архитектурой x64

GOOS=linux GOARCH=arm go build -o hello_linux_arm # Файл для Linux на arm

GOOS=darwin GOARCH=arm64 go build -o hello_mac_arm64 # Файл для MacOS на arm с архитектурой x64
```

## Пакеты

Любой код в Go существует в рамках пакета — это папка с Go файлами. Заголовки всех файлов в пакете начинаются с *package имя-пакета*.

В сообществе Go-разработчиков принято давать имена пакетам только в  нижнем регистре. Не должно быть camelCase, snake_case или kebab-case.  Если очень нужно использовать больше одного слова, то стоит использовать аббревиатуру. Хороший пример — пакет *bufio* (buffer io) из стандартной библиотеки.

## Пакет `main`

Чтобы Go-программу можно было скомпилировать из запустить из консоли используется пакет `main`:

```go
// Файл ./main.go
package main

import "fmt"

func main() {
  fmt.Println("Hello, Hexlet!")
}
```

Его единственное отличие от любого другого пакета — в нем содержится функция `main`, которая не принимает аргументы и не возвращает значения. Команды `go build` и `go run` ищут функцию `main` внутри пакета *main* и собирают исполняемый файл, который вызывает функцию `main`. Эта функция — точка входа в программу.

## Импорт и экспорт

Чтобы импортировать пакет, достаточно указать относительный или  абсолютный путь до него в блоке импортов. При этом в Go нет возможности  импортировать только одну переменную или функцию из пакета.

```go
// Файл ./main.go
package main

import (
  "./greeting" // Относительный импорт
  "fmt"
)

func main() {
 fmt.Println(greeting.Get())
}
```

Относительный на данный момент не явлется рекомендованным, вместо него рекомендуется использовать модульную go модули, для этого нужно инциализровать модуль в корне проекта командой:

```bash
go mod init <name>
```

После этого пакеты можно будет импортировать таким образом:

```go
import (
  "<name>/greeting"
)
```

### Алиасы

Чтобы импортировать два разных пакета с одинаковым именем, нужно добавлять **алиасы** к импортам пакетов:

```go
import (
  greetingv1 "./greeting"
  greetingv2 "./greeting/v2"
  "fmt"
)
```

Теперь можно обращаться к пакету первой версии по имени *greetingv1*, а ко второй — *greetingv2*. Если убрать алиасы, то компилятор вернет ошибку `greeting redeclared as imported package name`.

В Go есть способ импортировать все экспортируемые переменные из пакета,  при этом не используя имя пакета. Если дать пакету алиас `.`, то из пакета импортируются все переменные и функции, будто бы они были объявлены внутри текущего пакета.

## Модули

В Go модулем принято называть любое приложение, которое можно  опубликовать, версионировать, импортировать или скачать. С помощью  модулей мы можем управлять зависимостями.

Импорт модуля:

```go
package main

import "github.com/sirupsen/logrus" // Указываем путь до нужного пакета внутри репозитория

func main() {
    logrus.Println("Hello, Hexlet!")
}
```

Чтобы код запустился, надо этот пакет установить. Для этого можно использовать команду `go get`:

```bash
GO111MODULE=off go get "github.com/sirupsen/logrus" # О назначении GO111MODULE чуть позже
```

Далее можно запускать пакет командой `go run`:

```bash
GO111MODULE=off go run .

INFO[0000] Hello, Hexlet!
```

Зависимость установилась, и код заработал. Здесь используется переменная окружения `GO111MODULE=off` — именно эта переменная отключает систему модулей.

### Создание модуля

Моудль создаётся командой: 

```bash
go mod init <name>
go mod init github.com/hexlet/hello-hexlet
```

После этого создасться файл _go.mod_ с примерно таким содержимым:

```
module hexlet-go

go 1.21.4
```

Здесь содержиться имя модуля а также минимальная совместимая версия Go и список зависимостей, обновить его, можно воспользоваться командой `go get`, убрав переменную `GO111MODULE=off`. Но есть и другой способ — команда `go mod tidy`:

```
go mod tidy

go: finding module for package github.com/sirupsen/logrus
go: downloading github.com/sirupsen/logrus v1.8.1
go: found github.com/sirupsen/logrus in github.com/sirupsen/logrus v1.8.1
go: downloading golang.org/x/sys v0.0.0-20191026070338-33540a1f6037
go: downloading github.com/stretchr/testify v1.2.2
go: downloading github.com/pmezard/go-difflib v1.0.0
go: downloading github.com/davecgh/go-spew v1.1.1
```

Команда `go mod tidy` проверяет импорты в коде, загружает недостающие зависимости и удаляет лишние).

Также появился файл *go.sum*.

Оба файла обновляются при каждом добавлении или удалении зависимости:

- Файл *go.mod* включает путь до модуля и его версию

- Файл 

  go.sum

   добавляет по две записи на каждую зависимость:

  - Первая запись с названием модуля, его версией и хэш-суммой
  - Вторая запись с хэш-суммой *go.mod* файла модуля

## Версии зависимостей

По умолчанию Go ставит последнюю версию пакета, проверить доступные версии можно комадной `go list`:

```bash
go list -m --versions github.com/sirupsen/logrus

github.com/sirupsen/logrus v0.1.0 v0.1.1 v0.2.0 ... v1.7.0 v1.7.1 v1.8.0 v1.8.1
```

По умолчанию команда `go list` выдает адрес текущего пакета, по которому его можно импортировать. В примере выше мы использовали два флага:

- `-m` указывает, что нас интересует только модуль, а не его пакеты
- `--versions` указывает все возможные для скачивания версии пакета

Чтобы изменить версию, используем команду `go get`:

```bash
go get github.com/sirupsen/logrus@v1.5.0
```

### Удаление зависимостей

Для удаление достаточно удалить импорт этой зависимости из кода и запустить `go mod tidy`. В обновленном файле *go.mod* этого модуля больше не будет.

## Публикация модулей

В Go используется нестандартная система публикации модулей. В отличие от большинства других популярных языков, в Go не нужно  самостоятельно загружать код в централизованные репозитории. Каждый  Go-модуль публикуется только в репозиториях исходного кода, например, на GitHub или GitLab.

### Загрузка через прокси-сервер

Команда `go` не загружает пакеты напрямую из хранилищ исходного кода, а опрашивает [прокси-сервер](https://proxy.golang.org/).

Этот сервер хранит все публичные Go-модули во всех версиях. Если модуль или запрошенная версия отсутствуют на сервере, то прокси  попытается сохранить их у себя, прежде чем отдать пользователю. Такая  система защищает пользователей от потери доступа к пакету, если автор  изменит нужный тег, перезапишет его или удалит пакет целиком.

### Поиск пакета в прокси

Например, нужно поставить пакет [Io](https://github.com/samber/lo):

```go
package hxlt

import (
    "github.com/samber/lo"
)

func isEven(x int, _ int) bool {
    return x%2 == 0
}

func Even(vals []int) []int {
    return lo.Filter[int](vals, isEven)
}
```

Вызов команды `go get github.com/samber/lo@latest` проверит переменную окружения `GOPROXY`, допустим она содержит список прокси-серверов:

```
https://corp.example.com,https://proxy.golang.org
```

Тогда команда `go` выполнит следующие шаги:

- Запросит последнюю версию `github.com/samber/lo` от сервера `https://corp.example.com/`
- Запросит последнюю версию `github.com/samber` от сервера `https://corp.example.com/`
- Запросит последнюю версию `github.com` от сервера `https://corp.example.com/`

Представим, что все запросы к https://corp.example.com/ выдали ошибку 404 или 410. Тогда команда перейдет к следующей записи:

- Запросит последнюю версию `github.com/samber/lo` от сервера `https://proxy.golang.org/`
- Запросит последнюю версию `github.com/samber` от сервера `https://proxy.golang.org/`
- Запросит последнюю версию `github.com` от сервера `https://proxy.golang.org/`

Если в результате найдется один модуль с именем `github.com/samber/lo` и пакетом `lo`, то команда `go` обновит файлы *go.mod и go.sum* и скачает сам пакет.

### Поиск последней версии пакета

В запросе `go get` можно использовать атрибут `@latest` и тогда go определит последнюю версию запрашиваемого пакета.

Допустим в запрашиваемом репозитории есть несколько тегов и веток:

- Ветка main
- Ветка v2
- Тег v1.0.0
- Тег 1101-1663105068

В этом случае последней версией будет считаться тег `v1.0.0`, т.к. Go отдаёт предпочтения тегам перед ветками. **Используются только теги начинающиеся с `v` и следующие [семантическому версионированию](https://go.dev/ref/mod#versions)**

Если в проекте нет тегов, команда создает [псевдо-версию](https://go.dev/ref/mod#pseudo-versions), используя последний коммит.

### Публикация

Процес публикации состоит из нескольких шагов:

```bash
go mod init github.com/hexlet-components/hxlt
```

Запускаем `go mod tidy`, для загрузки недостающих пакетов и удаления лишних.

```bash
go mod tidy
```

Далее нужно отформатировать ком с помощью `go fmt`.

Далее нужно проверить код линтерами, для Go их множество, есть утилиты-агрегаторы, например [golangci-lint](https://golangci-lint.run/).

Добавляем тег в репозиторий:

```bash
git commit -am "feat: changes for v0.0.1"
git tag v0.0.1
git push origin v0.0.1
```

Модуль готов к скачиванию! Чтобы пользователи смогли найти его до загрузки, можно запустить команду `go list` — она добавит модуль в [индекс go.pkg](https://go.dev/blog/module-mirror-launch).

### Добавление обратно несовместимых изменений

Если нужно внести ломающие изменения, не получиться ограничить добавление тега с мажорной версией, нужно также сделать:

Обновить _go.mod_, чтобы он содержал в названии новую мажорную версию пакета. Сохраним текущий код в ветке `v1`:

```bash
git branch v1
```

Обновим *go.mod* файл, добавив ему в название `v2`:

```bash
go mod edit -module github.com/hexlet-components/hxlt/v2
```

Если бы в проекте было несколько пакетов, то для папки с `v2` пришлось бы обновить все импорты, чтобы они включали суффикс `v2`. Добавим тег и опубликуем:

```bash
git tag v2.0.0
git push origin v2.0.0
```