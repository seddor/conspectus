# Hello world

```go
// Определение пакета (выполняет роль неймспейсов) main
package main
// Импорт пакета fmt
import "fmt"
// Определение функции main
func main() {
  // Вызов функции Print из пакета fmt
  // Отступ 1 таб
	fmt.Print("Hello, World!")
}
```

Все Go-файлы начинаются с объявления пакета, к которому они относятся.

`main()` — главная функция, выполняемая при запуске любой Go-программы, является точкой входа, не может принимать или возвращать какие-либо аргументы.

После названия пакета распологается блок импорта.

В Go:

* публичные функции пишутся с большой буквы;
* приватные с маленькой.

Для строк в основном используются двойные кавычки `"`.

**Для отступов используются только табы**

## GO

Go — компилируемый и стороготипизируемый язык.

В Go нет исключений. Вместо них используется встроенный интерфейс `error`. Ошибки возвращаются явно последним аргументом из функции. Поэтому Go-код выглядит как череда вызовов функций и проверок на ошибки:

```go 
func main() {
    msg, err := DecodeJSON("")
    if errors.Is(err, errEmptyMessage) {
        // { } empty message
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON("hello")
    if err != nil {
        // { } unmarshal: invalid character 'h' looking for beginning of value
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON(`{"sender":"hexlet","text":"Go,Go,Go"}`)
    // {hexlet Go,Go,Go} <nil>
    fmt.Println(msg, err)
}
```

Самая сильная сторона Go — простое написание конкуретных программ. Для это используются легковесные потоки — горутины. Пример программы суммирующей 10 значений из разных источников:

```go
import (
    "fmt"
    "sync"
)

func main() {
    mu := sync.Mutex{}
    wg := sync.WaitGroup{}

    sum := 0
    for i := 0; i < 10; i++ {
        wg.Add(1)

        // ставим перед любой функцией слово «go», и она выполняется конкурентно в горутине
        go func() {
            // делаем долгий вызов к стороннему API. Так как каждый вызов происходит в своей горутине, мы делаем 10 вызовов одновременно
            n := externalHTTPNum()

            mu.Lock()
            sum += n
            mu.Unlock()

            wg.Done()
        }()
    }

    // ждем, пока все 10 горутин вернут ответ
    wg.Wait()

    fmt.Println(sum) // 55
}
```

## Переменные

Существуют два способа объявления переменных:

* Длинная запись с использованием `var`:

```go
var num int = 10
// или
var num = 10
```

* Короткая запись:

```go
num := 10
```

Изменение значений:

```go
// двоеточие используется только при инициализации
num := 10
num = 20
```

Переменные принято называть в `camelCase`.

Если не завадать значение переменной при инициализации она будет иметь нулевое значение:

```go
var {
  a string // ""
  b bool // false
  c int // 0
}
```

Объявлять переменные можно на уровне функций и пакетов. Прерменные на уровне пакетов будут инициализированны при старте программы. Такие переменные используются не часто. Например, в них можно записывать статические ошибки:

```go
package math

import "errors"

// статичная ошибка
var errCannotSum = errors.New("cannot sum")

func sum(...)
```

В Go принято называть переменные наиболее просто в макимально скоращённом, но доступном для понимания виде:

```go
// плохо
message := ""
buffer := bytes.Buffer{}
// хорошо
msg := ""
buf := bytes.Buffer{}
```

## Функции

Объявляются через ключевое слово `func`:

```go
func multiply(x int, y int) int {
  return x * y
}
```

Здесь:

* `func` — ключевое слово;
* `multiply` — название;
* `(x int, y int)` — входящие аргументы, если несколько аргументов имеет один тип, то можно сократить до `(x, y int)`
* `int` – тип возвращаемого значения

Функции именуются в `camelCase`, если функция именуется с заглавной буквы, то функция экпортируемая (публичная), если с маленькой то доступна только в рамках текущего пакета (приватная).

Функция может возвращать несколько значений, чаще всего это используется для возвращения ошибок:

```go
package math

import "errors"

func divide(x, y int) (int, error) {
    if y == 0 {
        return 0, errors.New("cannot divide on zero")
    }

    return x / y, nil
}
```

Возвращаемые значения можно именовать:

```go
func multiply(x, y int) (res int) {
    res = x * y
    return
}
```

Однако, это сичтается плохой практикой.

При использовании внешней функции нужно указывать имя пакета и через `.` вызываеть публичную функцию.

```go
import "fmt"

func myPrint(msg string) {
    // пакет.функция
    fmt.Println(msg)
}
```

## Числа и операции с ними

В Go есть множество числовых типов данных: uint`, `uint8`, `uint16`, `uint32`, `uint64`, `int`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`, `complex64`, `complex128.

Это нужно для кросплатформенность, в коде достаточно использовать `int` и `unit`, а в момент компиляции они будут преобразованные в необходимые типы для целевой архитектуры.

В основом коде используют:

- `int` — основной кросплатформенный тип целых чисел, может быть отрицательным
- `int64` нужен для больших чисел из внешних систем. Например, ID в СУБД имеет тип `bigint`. Чтобы правильно распарсить такой ID, используется `int64`
- `float64` — число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max()`, определяющая наибольшее число, принимает аргументы в виде `float64`

Стандартные арифметические операции:

```go
x := 10
y := 5

// сложение
x + y // 15
// вычитание
x - y // 5
// деление
x / y // 2
// умножение
x * y // 50
```

Любые операции осуществляются только над числами одного типа.

Чтобы работать с несколькими типа необходимо использовать явное приведения к типу:

```go

x := 5.05
y := 10

x + float64(y)  // 15.05
```

В основом числовые типы конвертируются без проблем между собой, но нужно учитывать некоторые нюансы:

```go
// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer
x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```

## Логические типы

Логичесие типы представлены `true` и `false`, а также операторами:

* `&&` (и)
* `==` (равно)
* `||` (или)
* `!` (не)

Объявление происходит через ключевое слово `bool`:

```go
var b bool = true
bs := false
```

Для проверки не логических типов нужно приводить их к логическим выражениям:

```go
flag := true
text := "hello"

// вариант не сработает, потому что нельзя конвертировать строку в bool
flag && bool(text) // cannot convert text (type string) to type bool

// правильный вариант: если строка не пустая, то в ней есть текст
flag && text != "" // true
```

## Строки

Строки объявляются с типом `string`:

```go
var s string = "hello"

// сокращенная запись
s := "hey"
```

Практически всегда используются довойный ковычки, кроме случая, когда нужно объявить несколько строк, в этом случае используются обратные кавычки:

``` go
q := `
    SELECT *
    FROM person
    WHERE age > 18
`
```

Строки можно сравинивать операторами, строки сравниваются посимвольно в лексическом порядке (по алфавиту) и по длине. Это свойство часто используется при сортировке массива строк:

```go
"привет" == "привет" // true
"golang" > "go" // true
"golang" > "lang" // false
"go" > "foobar" // true
```

Конкатенация осуществляется с помощью `+`.

В Go интерполяция осуществляется черезз функцию `fmt.Sprintf()`:

```go
username := "Ivan"
greetings := fmt.Sprintf("hello, %s", username) // "hello, Ivan"
```

Узнать длину строки можно с помощью встроенной функции `len()`:

```go
len("go") //2
// функция сичитает количество байт, а не реальную длину строки
len("го") // 4
```

## Условные конструкции

Условия представленые конструкцией `if else`. В условии должно быть выражение логического типа:

```go
package main

import (
    "fmt"
    "strings"
)

func statusByName(name string) string {
    // функция проверяет, что строка name начинается с подстроки "Mr."
    if strings.HasPrefix(name, "Mr.") {
        return "married man"
    } else if strings.HasPrefix(name, "Mrs.") {
        return "married woman"
    } else {
        return "single person"
    }
}

func main() {
    n := "Mr. Doe"
    fmt.Println(n + " is a " + statusByName(n)) // Mr. Doe is a married man

    n = "Mrs. Berry"
    fmt.Println(n + " is a " + statusByName(n)) // Mrs. Berry is a married woman

    n = "Karl"
    fmt.Println(n + " is a " + statusByName(n)) // Karl is a single person
}
```

Логическое выражение пишется после `if` без скобок. `else if` можно написать только раздельно.

## Switch

Switch по синтаксису схож с реализацией в других языках, но по логике отличается, если в кое-либо условие выполняется, то выполняется блок этого условия и происходит выходит из switch, использание `break` для этого не требуется:

 ```go
 x := 10
 
 switch x {
     default: // default всегда выполняется последним независимо от расположения в конструкции
         fmt.Println("default case")
     case 10:
         fmt.Println("case 10")
 }
 Output:
 
 case 10
 ```

При необоходимости можно реализовать логику, чтобы выполнение не прерывалось, для этого используется `fallthrough`:

```go
x := 10

switch { // выражение отсутствует. Для компилятора выглядит как: switch true
    default:
        fmt.Println("default case")
    case x == 10:
        fmt.Println("equal 10 case")
        fallthrough
    case x <= 10:
        fmt.Println("less or equal 10 case")
}
Output:

equal 10 case
less or equal 10 case
```

**Стоит учитывать, что `fallthrough` переводит выполнение к следующему блоку, даже если выражение в усолвии не выполняется**

## Структуры

В Go нет классов и привычной реализации ООП. Вместо классов используются структуры — наборы полей, Имеющих название и тип данных. Объявление стуктуры имеет следующий вид:

```go
type Person struct {
    // [название поля] [тип данных]
    Name string
    Age int
}

func main() {
    p := Person{Name: "John", Age: 25}

    p.Name // "John"
    p.Age // 25
}
```

Структуру можно инициализировать, не передавая значения. В этом случае каждое поле примет свое «нулевое» значение:

```go
func main() {
    p := Person{}

    p.Name // ""
    p.Age // 0
}
```

Регистр первой буквы в структурах обозначает публичность, так же как в переменных и функциях.

У любого поля структуры можно указать теги. Они используются для  метаинформации о поле для сериализации, валидации, маппинга данных из БД и тд. Тег указывается после типа данных:

```go
type User struct {
    ID int64 `json:"id" validate:"required"`
    Email string `json:"email" validate:"required,email"`
    FirstName string `json:"first_name" validate:"required"`
}
```

Тег `json` используется для названий полей при сериализации/десериализации структуры в json и обратно:

```go
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID        int64  `json:"id"`
    Email     string `json:"email"`
    FirstName string `json:"first_name"`
}

func main() {
    u := User{}
    u.ID = 22
    u.Email = "test@test.com"
    u.FirstName = "John"

    bs, _ := json.Marshal(u)

    fmt.Println(string(bs)) // {"id":22,"email":"test@test.com","first_name":"John"}
}
```

Тег `validate` используется Go-валидатором.

```go
package main

import (
    "fmt"
    "github.com/go-playground/validator/v10"
)

type User struct {
    ID        int64  `validate:"required"`
    Email     string `validate:"required,email"`
    FirstName string `validate:"required"`
}

func main() {
    // создали пустую структуру, чтобы проверить валидацию
    u := User{}
    // создаем валидатор
    v := validator.New()
    // метод Struct валидирует переданную структуру и возвращает ошибку `error`, если какое-то поле некорректно
    fmt.Println(v.Struct(u))
}
```

## Константы

Константы объявляются через `const`:

```go
const StatusOk int = 200
```

На практике констакты обычно объявляются так:

```go
const (
    StatusOk = 200
    StatusNotFound = 404
)
```

Для констант допустимы такие типы данных:

* Строки;
* Числа;
* Логические типы;

Регист первой буквы название влияет на уровнь доступа константы.

Константы можно объявлять как не уровне функций, так и пакета:

```go
package main

import "fmt"

const defaultStatus = 200

func main() {
    const status = 404

    fmt.Println("default status:", defaultStatus) // default status: 200
    fmt.Println("current status:", status) // current status: 404
}
```

Для последовательных числовых констант следует использовать идентификатор `iota`, который присвоит для списка чисел значения от его текущей позиции:

```go
package main

import "fmt"

const (
    zero = iota
    one
    two
    three
)

const (
	a = iota
	b = 42
	c = iota
	d
)

func main() {
	fmt.Println(zero, one, two, three) // 0 1 2 3
	fmt.Println(a, b, c, d)            // 0, 42, 2, 3
}
```

## Массивы

Массив — коллекция однотипных значений, фиксированной длины:

```go
nums := [5]int{}
```

Длина массива указвается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:

```go
nums := [5]int{} // [0, 0, 0, 0, 0]
// длинная инициализация
var nums [5]int // [0, 0, 0, 0, 0]
```

При попытке инициализации элементов за границей массива выходит ошибка компиляции:

```go
nums := [1]int{1,2} 
```

Чтение и запись происходит через квадратные скобки:

```go
nums := [3]int{1, 2, 3}
fmt.Println(nums[1]) // 2

nums[2] = 33
fmt.Println(nums) // [1, 2, 33]
```

Нумерация элементов массива начинается с 0, при попытке чтения за границей будет ошибка компиляции.

Массивы передаются по значению — т.е. лебое изменение внутри функции не виляет на исходный массив.

В Go есть встроенная функция `len()`, которая возвращает длину массива:

```go
fmt.Println(len([5]int{1,2,3})) // 5
fmt.Println(len([10]int{})) // 10
```

Так как массивы инициализируются с фиксированной длинной, то функция `len()` всегда возвращает одно и то же значение.

## Слайсы

Слайсы — массив неопределённой длины (или динамический массив):

```go
var nums = []int{1,2,3}

nums := []int{1,2,3}
```

Чтение и запись осуществляется так же как в массиве:

```go
nums := []int{1,2,3}
nums[2] // 3
nums[0] = 10 // [10, 2, 3]
// с помощью оператора : можно получить элементы от нижней до верхней границы
nums[1:3] // [2, 3]
nums[:2] // [10, 2]
nums[2:] // [3]
```

В слайсы можно добавить элементы с помощью встроенной функции `append`:

```go
words := []string{"hello"}

words = append(words, "world") // ["hello", "world"]
```

Внутри себя слайс, помимо самих элементов, хранит 2 дополнительных свойства: длину массива (`len`) и вместимость массива ( `cap`). Благодаря этому можно инциализровать слайс нужной длины с помощью функции `make`:

```go
// len = 5. Массив сразу будет заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5. Массив будет пустым, однако заполнение слайса через append будет эффективным, потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
```

Передача слайса в качестве аргумета функции происходит так: длина и вместимость передаются по значению, но массив значений передаётся по ссылке, таким образом выходит, что добавление элементов не сохраняется в исходный слайд, но изменение остаются:

```go
package main

import (
    "fmt"
)

func main() {
    nums := []int{1, 2, 3, 4, 5}

    modifySlice(nums)

    fmt.Println(nums) // [1 2 10 4 5]
}

func modifySlice(nums []int) {
    nums[2] = 10 // элемент будет и в исходном слайсе
    nums = append(nums, 6) // элемент не добавится в исходный слайс
}
```

Для слайсов можно распаковывать значение с помощью `...`:

```go
nums := []int{1, 2, 3, 4, 5}
nums[]...
```

## Цикл for

Обход коллекций осуществляется только через цикл `for`:

```go
nums := make([]int, 0, 10)

// начиная с 0; пока i меньше 10; инкрементим i после каждого шага
for i := 0; i < 10; i++ {
    nums = append(nums, i)
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

При необходимости `for` используется как `while`:

```go
i := 0
nums := make([]int, 0, 10)

for i < 10 {
    nums = append(nums, i)
    i++
}

fmt.Println(nums) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Если опучстить условие, то можно уйти в бесконечный цикл.

Если условное выражение возвращает `false` или был вызыван `break` в теле цикла, то происходит остановка цикла. Для перехода к следующей итерации используется `continue`:

```go
nums := make([]int, 0, 10)

// добавляем только четные числа в слайс
for i := 0; i < 10; i++ {
    if i % 2 != 0 {
        continue
    }

    nums = append(nums, i)
}

fmt.Println(nums) // [0 2 4 6 8]
```

Для обхода коллекции есть `range`:

```go
names := []string{"John", "Harold", "Vince"}

// i — это индекс, name — это значение на текущем шаге цикла
for i, name := range names {
    fmt.Println("Hello ", name, " at index ", i)
}
```

## Копирование слайсов

Функция `copy(dst, src []Type) int` копирует слайс `src` в слайс `dst` и возвращает колиечство скопированных элементов:

```go
nums := []int{1,2,3,4,5}

// важно инициализировать слайс той же длины
numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp) // [1,2,3,4,5]
```

При копировании выжно соответствие длины слайсов, если если элементы будут выходить за длину `dst` то они не будут скопированны:

```go
nums := []int{1, 2, 3, 4, 5}

// создали слайс с длиной 0
numsCp := make([]int, 0)

// при копировании в пустой слайс ничего не произойдет
copy(numsCp, nums)

fmt.Println(numsCp) // []
```

## Сортировка слайсов

Стандартный пакет `sort` предоставляет функции для сортировки:

```go
nums := []int{2,1,6,5,3,4}

sort.Slice(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Рассмотрим функцию `Slice(x interface{}, less func(i, j int) bool)`. Следует запомнить, что пустой интерфейс `interface{}` в Go означает тип данных, под который подходит любой другой тип.

В функцию `Slice(x interface{}, less func(i, j int) bool)`  передается слайс любого типа данных, как первый аргумент. Вторым  аргументом передается функция, которая берет элементы по индексу и  определяет должен ли элемент по индексу `i` находиться перед элементом по индексу `j`.

Внутри функции **sort.Slice** используется быстрая сортировка. В пакете также присутствует сортировка вставками `sort.SliceStable`:

```go
nums := []int{2,1,6,5,3,4}

sort.SliceStable(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Выбор алгоритма зависит от набора и размера данных, архитектуры  процессора, скорости доступа к памяти, то есть от многих факторов. Для  большинства стандартных случаев используется `sort.Slice`

## Мап

Map — тип данных, предназначеный для хранения пар ключ-знамения (в других языках: хэш-таблица, словарь, асоциативный массив):

```go
// создание пустой мапы
var m map[int]string

// сокращенное создание пустой мапы
m := map[int]string{}

// рекомендуемое создание с обозначением размера
m := make(map[int]string, 10)

// создание мапы с элементами
m := map[int]string{1: "hello", 2: "world"}

// добавление элемента
m[3] = "!" // map[1:hello, 2:world, 3:!]

// чтение элемента
word := m[1] // "hello"
```

При чтении элемента по несуществующему ключу возвращается нулевое значение типа. При использовании bool как значения это приводит к ошибкам логики, для решения этого используется вторая переменная, в которую записывается наличие жлемента в мапе:

```go
elements := map[int64]bool{1: true, 2: false}

element, elementExists := elements[1] // true, true
element, elementExists := elements[2] // false, true
element, elementExists := elements[225] // false, false

// пустая структура struct{} — это тип данных, который занимает 0 байт
// используется, когда нужно проверять в мапе только наличие ключа
cache := make(map[string]struct{})

// проверяем есть ли ключ `key` в мапе
_, ok = cache["key"]
fmt.Println(ok)  // false

// добавим ключ и проверим вновь
cache["key"] = struct{}{}
_, ok = cache["key"]
fmt.Println(ok)  // true

```

Элементы удаляются с помощью функции `delete(m map[Type]Type1, key Type)`:

```go
engToRus := map[string]string{"hello":"привет", "world":"мир"}

delete(engToRus, "world")

fmt.Println(engToRus) // map[hello:привет]
```

Мапы всегда передаются по ссылке

## Обход мап

Как и слайс, мапу можно обойти с помощью `for range`:

```go
idToName := map[int64]string{1: "Alex", 2: "Dan", 3: "George"}

// первый аргумент — ключ, второй — значение
for id, name := range idToName {
    fmt.Println("id: ", id, "name: ", name)
}
```

Стоит учитывать, что порядок ключей в мапе рандомизирован.

## Строки и байты

Строки в Go — это иммутабельные массивы байт. Для стандартного компилятора Go внутренняя структура строки описана как:

```go
type _string struct {
    elements *byte // байты
    len      int   // кол-во байт
}
```

После инициализации строку нельзя изменить и такая иммутабельность позволяет избежать побочных эффектов в коде.

```go
s := "hello"
s[4] = "" // ошибка компиляции: cannot assign to s[4] (strings are immutable)
```

Стоит отметить, что тип данных `byte` — это алиас к типу `uint8` (0-255). Во-первых, потому что нужно абстрактно отличать типы в коде.  Во-вторых, байты представляют ASCII символы, а в кодовой таблице ASCII  символов 256 кодов:

```go
package main

import "fmt"

func main() {
    s := "hey"

    fmt.Println(s[0], s[1], s[2]) // 104 101 121

    fmt.Println(string(s[0]), string(s[1]), string(s[2])) // h e y
}
```

Большинство библиотечных функций работают со слайсами байт `[]byte` для производительности. Конвертация строки в слайс байт описывается в коде явно:

```go
package main

import "fmt"

func main() {
    s := "hey"
    bs := []byte(s)

    fmt.Println([]byte(s)) // [104 101 121]

    fmt.Println(string(bs)) // hey
}
```

Отдельные ASCII символы можно объявлять сразу с типом `byte`. Для этого нужно обернуть символ в одинарные кавычки и указать тип `byte`:

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    asciiCh := byte('Q')
    asciiChStr := string(asciiCh)

    fmt.Println(reflect.TypeOf(asciiCh), asciiCh) // uint8 90

    fmt.Println(reflect.TypeOf(asciiChStr), asciiChStr) // string Q
}
```

## Обход строки

Строки можно обходить с помощью `for`:

```go
package main

import (
    "fmt"
)

func main() {
    s := "hello"
    for i := 0; i < len(s); i++ {
        fmt.Println(string(s[i]))
    }

}
```

Однако, это корректно будет работать только со строками из ASCII символов, при работе с многобайтовыми строка вывод будет некорректным.

## Руны

Для работы с юникод-символами в Go есть тип `rune`:

```go
package main

import (
    "fmt"
)

func main() {
    emoji := []rune("привет😀")

    for i := 0; i < len(emoji); i++ {
        fmt.Println(emoji[i], string(emoji[i])) // выводим код символа и его строковое представление
    }
}
```

`rune` — алиас к `int32`. Как и байты, руны были созданы для отличия от встроенного типа данных. Каждая рунна — это код символа Юникода. Строка преобразуется в `byte[]` и `rune[]`, но между собой эти два типа не конвертируются напрямую.

В Go присутствует синтаксический сахар при обходе строки. Если использовать конструкцию `for range`, строка автоматически будет преобразована в `[]rune`, то есть обход будет по Юникод символам:

```go
package main

import (
    "fmt"
)

func main() {
    emoji := []rune("cool😀")

    for _, ch := range emoji {
        fmt.Println(ch, string(ch)) // выводим код символа и его строковое представление
    }
}
```

## Стандартный пакет strings

Для работы со строками существует пакет `strings`, который содержит основные функции. Например часто используются функции:

```go
import "strings"

// проверяет наличие подстроки в строке
strings.Contains("hello", "h") // true

// разбивает строку по Юникод символам или по переданному разделителю
strings.Split("hello", "") // ["h", "e", "l", "l", "o"]

// склеивает строки из слайса с разделителем
strings.Join([]string{"hello","world!"}, " ") // "hello world!"
```

Важная часть этого пакета —это `Builder`. Когда необходимо собрать большую строку по каким-то правилам лучше не использовать конкатенацию, а использовать `Builder`:

```go
import "strings"

sb := strings.Builder{}

sb.st("hello")
sb.WriteString(" ")
sb.WriteString("world")

sb.String() // "hello world"
```

[Пакет strings](https://pkg.go.dev/strings)

## Форматирование строк

Пакет `fmt` используется не только для вывода переменных или реультатов функций, но и для форматирования строк. Для подстановки значений используются плейсхолдеры:

```go
name := "Andy"

// подставляем строку
fmt.Sprintf("hello %s", name) // "hello Andy"

// число
fmt.Sprintf("there are %d kittens", 10) // "there are 10 kittens"

// логический тип
fmt.Sprintf("your story is %t", true) // "your story is true"
```

Также существуют специализированные плейсхолдеры, которые преобразуют сложные структуры:

```go
package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Andy", Age: 18}

    // вывод значений структуры
  	// simple struct: {Andy 18}
    fmt.Println("simple struct:", p)

    // вывод названий полей и их значений
  	// detailed struct: {Name:Andy Age:18}
    fmt.Printf("detailed struct: %+v\n", p)

    // вывод названий полей и их значений в виде инициализации
  	// Golang struct: main.Person{Name:"Andy", Age:18}
    fmt.Printf("Golang struct: %#v\n", p)
}
```

[Пакет fmt](https://pkg.go.dev/fmt)

## Вариативные функции

Последний аргумент функции может быть вариативным. Функция может иметь маскимум один вариативный агрумент и этот агрумент всегда слайс. Чтобы обозначить аргумент вариативным нужно поставить `…` перед его типом:

```go
package main

import (
    "fmt"
)

func main() {
    // кол-во аргументов может быть любым
    PrintNums(1, 2, 3)
}


func PrintNums(nums ...int) {
    for _, n := range nums {
        fmt.Println(n)
    }
}
```

Также `…` можно разбить слайс на элементы при предаче в вариативную функцию. Например, метод `append(slice []Type, elems …Type) []Type` принимает вариативный аргумент `elems …Type`. Чтобы добавить один слайс в конец другого, нужно разить второй слайс на элементы путем добавления  `…` после переменной:

```go
nums1 := []int{1,2,3,4,5}
nums2 := []int{6,7,8,9,10}

res := append(nums1, nums2...) // [1 2 3 4 5 6 7 8 9 10]
```

## Передача указателей в качестве аргумета функции

```go
package main

import (
    "fmt"
)

type User struct {
    email    string
    password string
}

// при объявлении указываем,
// что переменная должна быть указателем.
// Для этого ставим звездочку * перед типом данных
func fillUserData(u *User, email string, pass string) {
    u.email = email
    u.password = pass
}

func main() {
    u := User{}

    // передаем указатель с помощью амперсанда
    // & перед переменной
    fillUserData(&u, "test@test.com", "qwerty")

    fmt.Printf("points on func call %+v\n", u)
    // points on func call {email:test@test.com password:qwerty}

    // сразу инициализируем переменную с указателем
    up := &User{}

    fillUserData(up, "test@test.com", "qwerty")

    fmt.Printf("points on init %+v\n", up)
    // points on init {email:test@test.com password:qwerty}
}
```

Мапы по умолчанию передаются с указателем.

[Указатели в Go](https://gobyexample.com/pointers)

[Указатели](http://golang-book.ru/chapter-08-pointers.html)
