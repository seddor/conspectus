# Hello world

```go
// Определение пакета (выполняет роль неймспейсов) main
package main
// Импорт пакета fmt
import "fmt"
// Определение функции main
func main() {
  // Вызов функции Print из пакета fmt
  // Отступ 1 таб
	fmt.Print("Hello, World!")
}
```

Все Go-файлы начинаются с объявления пакета, к которому они относятся.

`main()` — главная функция, выполняемая при запуске любой Go-программы, является точкой входа, не может принимать или возвращать какие-либо аргументы.

После названия пакета распологается блок импорта.

В Go:

* публичные функции пишутся с большой буквы;
* приватные с маленькой.

Для строк в основном используются двойные кавычки `"`.

**Для отступов используются только табы**

## GO

Go — компилируемый и стороготипизируемый язык.

В Go нет исключений. Вместо них используется встроенный интерфейс `error`. Ошибки возвращаются явно последним аргументом из функции. Поэтому Go-код выглядит как череда вызовов функций и проверок на ошибки:

```go 
func main() {
    msg, err := DecodeJSON("")
    if errors.Is(err, errEmptyMessage) {
        // { } empty message
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON("hello")
    if err != nil {
        // { } unmarshal: invalid character 'h' looking for beginning of value
        fmt.Println(msg, err)
    }

    msg, err = DecodeJSON(`{"sender":"hexlet","text":"Go,Go,Go"}`)
    // {hexlet Go,Go,Go} <nil>
    fmt.Println(msg, err)
}
```

Самая сильная сторона Go — простое написание конкуретных программ. Для это используются легковесные потоки — горутины. Пример программы суммирующей 10 значений из разных источников:

```go
import (
    "fmt"
    "sync"
)

func main() {
    mu := sync.Mutex{}
    wg := sync.WaitGroup{}

    sum := 0
    for i := 0; i < 10; i++ {
        wg.Add(1)

        // ставим перед любой функцией слово «go», и она выполняется конкурентно в горутине
        go func() {
            // делаем долгий вызов к стороннему API. Так как каждый вызов происходит в своей горутине, мы делаем 10 вызовов одновременно
            n := externalHTTPNum()

            mu.Lock()
            sum += n
            mu.Unlock()

            wg.Done()
        }()
    }

    // ждем, пока все 10 горутин вернут ответ
    wg.Wait()

    fmt.Println(sum) // 55
}
```

## Переменные

Существуют два способа объявления переменных:

* Длинная запись с использованием `var`:

```go
var num int = 10
// или
var num = 10
```

* Короткая запись:

```go
num := 10
```

Изменение значений:

```go
// двоеточие используется только при инициализации
num := 10
num = 20
```

Переменные принято называть в `camelCase`.

Если не завадать значение переменной при инициализации она будет иметь нулевое значение:

```go
var {
  a string // ""
  b bool // false
  c int // 0
}
```

Объявлять переменные можно на уровне функций и пакетов. Прерменные на уровне пакетов будут инициализированны при старте программы. Такие переменные используются не часто. Например, в них можно записывать статические ошибки:

```go
package math

import "errors"

// статичная ошибка
var errCannotSum = errors.New("cannot sum")

func sum(...)
```

В Go принято называть переменные наиболее просто в макимально скоращённом, но доступном для понимания виде:

```go
// плохо
message := ""
buffer := bytes.Buffer{}
// хорошо
msg := ""
buf := bytes.Buffer{}
```

## Функции

Объявляются через ключевое слово `func`:

```go
func multiply(x int, y int) int {
  return x * y
}
```

Здесь:

* `func` — ключевое слово;
* `multiply` — название;
* `(x int, y int)` — входящие аргументы, если несколько аргументов имеет один тип, то можно сократить до `(x, y int)`
* `int` – тип возвращаемого значения

Функции именуются в `camelCase`, если функция именуется с заглавной буквы, то функция экпортируемая (публичная), если с маленькой то доступна только в рамках текущего пакета (приватная).

Функция может возвращать несколько значений, чаще всего это используется для возвращения ошибок:

```go
package math

import "errors"

func divide(x, y int) (int, error) {
    if y == 0 {
        return 0, errors.New("cannot divide on zero")
    }

    return x / y, nil
}
```

Возвращаемые значения можно именовать:

```go
func multiply(x, y int) (res int) {
    res = x * y
    return
}
```

Однако, это сичтается плохой практикой.

При использовании внешней функции нужно указывать имя пакета и через `.` вызываеть публичную функцию.

```go
import "fmt"

func myPrint(msg string) {
    // пакет.функция
    fmt.Println(msg)
}
```

## Числа и операции с ними

В Go есть множество числовых типов данных: uint`, `uint8`, `uint16`, `uint32`, `uint64`, `int`, `int8`, `int16`, `int32`, `int64`, `float32`, `float64`, `complex64`, `complex128.

Это нужно для кросплатформенность, в коде достаточно использовать `int` и `unit`, а в момент компиляции они будут преобразованные в необходимые типы для целевой архитектуры.

В основом коде используют:

- `int` — основной кросплатформенный тип целых чисел, может быть отрицательным
- `int64` нужен для больших чисел из внешних систем. Например, ID в СУБД имеет тип `bigint`. Чтобы правильно распарсить такой ID, используется `int64`
- `float64` — число с плавающей точкой. Чаще всего используются для математических операций. Например, функция `math.Max()`, определяющая наибольшее число, принимает аргументы в виде `float64`

Стандартные арифметические операции:

```go
x := 10
y := 5

// сложение
x + y // 15
// вычитание
x - y // 5
// деление
x / y // 2
// умножение
x * y // 50
```

Любые операции осуществляются только над числами одного типа.

Чтобы работать с несколькими типа необходимо использовать явное приведения к типу:

```go

x := 5.05
y := 10

x + float64(y)  // 15.05
```

В основом числовые типы конвертируются без проблем между собой, но нужно учитывать некоторые нюансы:

```go
// нельзя конвертировать float64 к целому числу, если после точки не только нули
x := int64(5.05) // ошибка компиляции: constant 5.05 truncated to integer
x := int64(5.00) // OK

// uint не может быть отрицательным
x := uint(-5) // constant -5 overflows uint
```

## Логические типы

Логичесие типы представлены `true` и `false`, а также операторами:

* `&&` (и)
* `==` (равно)
* `||` (или)
* `!` (не)

Объявление происходит через ключевое слово `bool`:

```go
var b bool = true
bs := false
```

Для проверки не логических типов нужно приводить их к логическим выражениям:

```go
flag := true
text := "hello"

// вариант не сработает, потому что нельзя конвертировать строку в bool
flag && bool(text) // cannot convert text (type string) to type bool

// правильный вариант: если строка не пустая, то в ней есть текст
flag && text != "" // true
```

