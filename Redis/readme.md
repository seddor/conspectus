# Redis

Redis — это БД, его особеностью является:

- *in-memory* означает, что данные хранятся в оперативной  памяти. Это накладывает ограничение на объем данных, который хранится в  Redis, но дает более быстрое чтение и запись по сравнению с длительными  хранилищами (NVME, SSD, HDD);
- *KV хранилище (key-value)*. В Redis нет таблиц, схем или  каких-либо других абстракций для доступа к данным. Все данные  записываются и получаются по ключам. Вследствие этого основные операции  выполняются за O(1).

Для работы с redis из терминала есть встроенный консольный клиент `redis-cli`.

## Redis как key-value хранилище

Для записи используется команда `set`:

```bash
set <key> <value>
```

* в ключах рекомендуется использовать двоеточие как разделитель слов  (хотя и встречаются другие подходы к наименованию). В примере с сессией  ключ имеет вид `session:{session_id}`;
* команда `set` записывает значение как строку. Одиночное  слово пишется без кавычек, но предложение придется писать в одинарных  или двойных кавычках `set key1 'hello world'`.

Для получения данных используется `get`:

```bash
get <key>
```

Если ключ не определён будет возвращено `(nil)`.

Для проверки наличия ключа используется `exists`:

```bash
exists <key>
```

Если ключ определён вернёт `1`, иначе `0`.

Для удаление используется `del`:

```b
del <key>
```

Возращает `1` если ключ удалён и `0` если ключа не было.

Для хранения дополнительной информации можно использовать JSON в качестве значения:

```
127.0.0.1:6379> set session:1 '{"user_id":120,"email":"test@test.com"}'
OK
127.0.0.1:6379> get session:1
"{\"user_id\":120,\"email\":\"test@test.com\"}"
```

Однако, с этим методом есть ряд недостатков:

1. логика по конвертированию в JSON выносится на уровень приложения. В  следующих уроках мы рассмотрим стандартный тип данных в Redis, который  позволяет хранить несколько значений по одному ключу;

2. для получения одного поля *user_id* нужно достать весь JSON и декодировать его. В Redis существует модуль [RedisJSON](https://redis.io/docs/stack/json/) для решения этой проблемы. Например, получение поля реализуется одной командой:

   ```bash
   JSON.GET session1 .user_id
   ```

[Commands](https://redis.io/commands/?group=string)

[SET](https://redis.io/commands/set/)

[GET](https://redis.io/commands/get/)

[DEL](https://redis.io/commands/del/)

## Redis как кэш

Redis чаще всего используют именно как кэширующий сервер. Он имеет  богатый встроенный функционал для этих целей.

При записи можно указать время жизни для ключа:

```bash
set <key> <value> ex <lifetime_in_seconds>
```

Проверить время жизни можно командой `ttl`:

```bash
ttl <key>
```

Также можно указать время в миллисекундах с помощью `px`:

```bash
set user:33:deals_count 5 px 10000
```

Для проверки времени жизни используется `pttl`:

```bash
pttl user:33:deals_count
```

### Инвалидация кэша

Для удаления используется команда `del`.

Если нужно удалить множество ключей используется команда `unlink`, она удаялет уключи асинхронно:

```bash
unlink <key1> <key2> ... <keyN>
```

[TTL](https://redis.io/commands/ttl/)

[PTTL](https://redis.io/commands/pttl/)

## Атомарные инкременты в Redis

Redis отлично подохдит для использования счётчиков.

### Инкремент

Для увелчичения инкримента используется команда `incr`:

```bash
incr <key>
```

На каждый запрос команда возвращает новое количество, после увеличения.

Также можно увеличить счётчик сразу в N раз:

```bash
incrby <key> <N>
```

[INCR](https://redis.io/commands/incr/)

[INCRBY](https://redis.io/commands/incrby/)

### Декремент

Для уменьшения используется команда `decr`:

```bash
decr <key>
```

Можно уменьшить в N раз:

```bash
decrby <key> <N>
```

[DECR](https://redis.io/commands/decr/)

[DECRBY](https://redis.io/commands/decrby/)

### Взаимодействие со счетчиком

Со счетчиком можно работать так же, как и с обычным ключом: получать значение, устанавливать время жизни, удалять:

```
127.0.0.1:6379> get page:hexlet.io/courses:online_count
"10"
127.0.0.1:6379> expire page:hexlet.io/courses:online_count 60
(integer) 1
127.0.0.1:6379> ttl page:hexlet.io/courses:online_count
(integer) 53
127.0.0.1:6379> del page:hexlet.io/courses:online_count
(integer) 1
```

[EXPIRE](https://redis.io/commands/expire/)

## Списки в Redis (Lists)

Списки в Redis — это список строк, упорядоченный в порядке вставки. Список может содержать более 4 миллиардов элементов. Самая главная  особенность списков в Redis — это возможность получать/читать/удалять  элементы с начала или конца списка за константное время O(1) даже при  общем размере в несколько миллионов.

### Запись элементов

Для добавление элемента в начало списка (слева) существует команда `lpush`, если спика не было он будет создан:

```bash
lpush <key> <value> [value]
```

Для добавление в конец используется команда `rpush`.

[LPUSH](https://redis.io/commands/lpush/)

[RPUSH](https://redis.io/commands/rpush/)

### Получение элементов

Для получения жлементов используется команда `lrange`:

```bash
lrange <key> <start_index> <stop_index>
```

Если указать правую границу как *-1*, то вернется весь список.

[LRANGE](https://redis.io/commands/lrange/)

### Удаление элементов

Есть несколько способов удаления элементов. Самый быстрый и  рекомендуемый — это удаление первого/последнего элементов списка с  помощью команд `lpop key`, `rpop key`:

```bas
lpop <key>
rpop <key>
```

`lpop` удаляет элемент из начала списка и возвращает его. Команда `rpop` делает то же самое только с конца.

Если количество элементов в списке маленькое, то можно использовать команду `lrem key 0 value`, которая ищет в списке значение и удаляет его. Команда `lrange` возвращает указанные элементы списка.

```bash
>lrem user:14:recent_posts 0 120
(integer) 0
>lrem user:14:recent_posts 0 20
(integer) 1
>lrange user:14:recent_posts 0 -1
(empty array)
```

Если элемент не был найден в списке, то возвращается *0*. В случае успешного удаления вернется *1*. Так как удалился последний элемент в списке, команда `lrange` вернула пустой массив.

[LPOP](https://redis.io/commands/lpop/)

[RPOP](https://redis.io/commands/rpop/)

### Время жизни

Время жизни списком можно задать командой `expire`.