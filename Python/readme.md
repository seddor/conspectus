# Hellow world

```python
# Helow, world
print('Hello, World!')
```

# Арифметические операции

* `+` — сложение;
* `-` — вычитание;
* `*` — умножение;
* `**` — возведение в стпень (`3 ** 2` # => 9);
* `/` — деление;
* `//` — целочисленное деление;
* `%` — оостаток от деления.

# Оформление

В Python используется один код стандарт — [PEP8](https://peps.python.org/pep-0008/).

Наиболее популярный линтер — [flake8](https://flake8.pycqa.org/en/latest/).

# Строки

Для обозначения строк используются:

* `"`
* `'`

Спец. символы:

* `\n` — перевод строки;
* `\t` — табуляция

Концкатенация строк происходит с помощью: `+`.

# Переменные

```python
variable = 'foo'
```

В python переменные не требуют специального объявления, переменные объявляются при первом использовании в программе.

Для имени переменных используется буквы английского алфавита, цифры и `_`. При этом цифру нельзя ставить в начале.

Константы задаются так же, как переменные. Разница в том, что константы принятно именовать заглавными буквами и использовать `_` в качестве разделителя.

Для переменных принято использовать `snake_case`.

# Интерполяция

```python
first_name = 'Joffrey'
greeting = 'Hello'

print(f'{greeting}, {first_name}!')
```

# Multi-line строки

Для Multi-line строк используются тройные кавычки:

```python
text = '''Пример текста,
состоящего из
нескольких строк'''
```

В них можно использовать интерполяцию:

```python
text = f'''{a} и {b}
сидели на трубе
'''
```

# Извлечение символов из строки

В python из строкм можно извлекать символы как из массива:

```python
first_name = 'Alexander'

print(first_name[0])  # => A
# Если импользовать отрицательные индексы, то извелечение будет происходить с конца строки.
print(first_name[-1])  # => r

# Извлечение подстроки
print(first_name[0:4])  # => Alex

value = 'Hexlet'
# Извелчение с указанного до конца строки
value[3:]  # 'let'
# Извлечение от начала до указанного
value[:3]  # 'Hex'
# Правая граница отрицательная. Считаем -1 от конца строки
value[3:-1]  # 'le'
# Левая граница отрицательная. Считаем -5 от конца строки
value[-5:3]  # 'ex'
```

## Шаг извлечения

У срезов есть 3й необязательный параметр — шаг извелчения.

```python
value = 'Hexlet'
value[1:5:2]  # el
# 1:5 это 'exle'
# шаг 2 значит через один, то есть 'e' и 'l'

# Переворот строки
value[::-1]  # 'telxeH'

value = 'Hexlet'
start = 1
end = 5
value[start:end]  # 'exle'
```

# Типы

В Python используется строгая типизация.

Преобрзаование типов в python происходит только явно с помощью специальных функций:

* `int()` — преобразование в целочисленное;
* `float()` — в число с плавающей точкой;
* `str()` — в строку.

# Функции

Для работы со строками:

* `len(str)` — количество символов
* `pow(2, 3)` — возведение в степень
* `round(10.25, 0)` — округляет

[Описание остальных функций](https://docs.python.org/3/library/functions.html)
[Справочник по стандартной библиотеи](https://docs-python.ru/standart-library/)

# Объекты

Строки в Python — это объекты. У них можно вызывать [методы строк](https://python.readthedocs.io/en/latest/library/stdtypes.html#string-methods)

Числа тоже по сути являются объектами:
```python
x = -5
abs(x)  # вызывает x.__abs__()
```

Имена методов начинающиеся и кончающиеся `__` — это специальное именование методов, которые не предпологается вызывать напрямую, обычно для таких методов есть специальные функции, которые внутри себя уже вызываут эти методы.

# Определение функций

```python
# Определение функции
# Определение не вызывает и не выполняет функцию
# Мы лишь говорим, что теперь такая функция существует
def show_greeting():
  # Внутри тела отступ четыре пробела
  text = 'Hello, Hexlet!'
  print(text)

# Вызов функции
show_greeting()  # => 'Hello, Hexlet!'

# Функция с возвратом значения
def greeting():
    return 'Hello, Hexlet!'

# Функция с параметрами
def greeting(name, greeting = 'Hello'):
    return f'{greeting}, {name}!'

# Минимальное определение функции
def noop():
  pass
```

## Именованные аргументы

В python есть два вида аргументов:

* Позиционные — передаются в том же порядке, в котором объявлены в функции:
```python
# (text, length)
truncate('My Text', 3)
```
* Именнованные — передаются в виде пары "имя=значение", могут передаваться в любом порядке:
```python
# (text, length)
truncate(length=3, text='My text')
```

Можно одновременно использовать два типа аргументов:
```python
# Передаем только a (позиционно) и d (как именованный)
f(3, d=3)
```

# Окружение

В python в функции видно все переменные, которые были определены до неё:

```python
age = 5

def generate():
    return age + 3

result = generate() # result == 8
```

Если в теле функции будет объявлена переменная с таким же именем, что и до неё, то в функции будет использоваться внткреняя, при этом это никак не повлияет на внешнюю переменную:

```python
age = 5

def generate():
    age = 10
    return age + 3

result = generate() # result == 13
```

# Логика

Операции сравнения:
* `<` — меньше;
* `<=` — меньше или равно;
* `>` — больше;
* `>=` — больше или равно;
* `==` — равно;
* `!=` — не равно.

Операторы:
* `and` — И (конъюнкция);
* `or` — ИЛИ (дизъюнкция);
* `not` — инверсия (отрицание).

## Преобразования

В python два правила преобразования:
* 0, 0.0, '' и None приводятся к False. Эти значения называют falsy;
* Все остальное приводится к True

Например:
```python
# в value будет присвоена пустая строка, если в name содержиться одно из falsy значений
value = name or ''
```

# Условные конструкции

```python
if time == '18:00':
    go_home()
else:
    work()    

# elseif
if last_char == '?':
    sentence_type = 'question'
elif last_char == '!':
    sentence_type = 'exclamation'
else:
    sentence_type = 'normal'
```
`elif` означает — если не выполнено предудущее условие, но выполнено текущее.

## Тернарный оператор

```python
def abs(number):
    return number if number >= 0 else -number
```
Общий паттерн выражения: `<expression on true> if <predicate> else <expression on false>`.

# Циклы

```python
# while
counter = 0
while counter < n:
    print('Hello')
    counter += 1

# for
text = 'code'
for symbol in text:
    print(symbol)
```

# Модули

В Python любой **файл с кодом** называется **модулем**.

## Импорт

```python
# Импорт gretting.py
import greeting

# вызываем функцию модуля
greeting.say_hi()  # => Hi!

# выводим на экран отдельную переменную
print(greeting.name)  # => Bob

# Частичный импрот
from greeting import say_hi, name # импортируем отдельные компоненты модуля

print(name)  # используем импортированную переменную
say_hi()     # вызываем импортированную функцию

# Импорт всего модуля (не рекомендуется использовать)
from some_module import *
```

# Пакеты

Пакеты — объединение модулей. С точки зрения структуры пакет — это директория с файлами модулей, имеющая имя в snake_case и содержащая, помимо прочего, специальный модуль с имением `__init__.py`.

В `__init__.py` содержится следующий код:

```python
NAME = 'super_package'
```

Импорт происходит также, как модуль:

```python
import package

print(package.NAME)

# Квалификационный импорт модулей из пакета
import package.functions
import package.constants

package.functions.greet(package.constants.PERSON)  # => Hello, Alice!

# Частичный импорт из пакета
from package.functions import greet
from package.constants import PERSON

greet(PERSON)  # => Hello, Alice!
```

Помимо этого также есть:

* Абсолютный импорт — когда прописывается **полный путь до модуля**;
* Относительный импорт — в относительном импорте используется `.`, которая означает **импорт модуля из текущей директории**:

```python
from . import module
from .module import function
from .subpackage.module import CONSTANT
```

# Кортежи

В python есть составные типы данных, один из них это — кортеж. Кортеж представляет из себя несколько значений, записанных через запятую.

```python
rgb_colour = (255, 127, 64)
name_and_age = ('Bob', 42)
three_booleans = (True, False, True)
two_pairs_of_numbers = ((1, 2), (3, 4))

# Кортеж из одного элемента
tuple = (42,)  # Ставим запятую, чтобы указать на кортеж
```

Кортежи полезны когда нужно вернуть несколько значений, например функция `div_mod` возвращает сразу результат деления нацело и остаток от деления:

```python
def div_mod(a, b):
    quotient = a // b
    modulo = a % b
    return (quotient, modulo)

div_mod(13, 4)  # (3, 1)
```

Для извлечения данных из кортежа нужно обратиться к ним по индексу:

```python
name_and_age = ('Bob', 42)

name_and_age[0]  # 'Bob'
name_and_age[1]  # 42

# Получения длины кортежа
len(name_and_age) # 2
```

Кортежи можно разбирать:

```python
name_and_age = ('Bob', 42)

(name, age) = name_and_age
name  # 'Bob'
age   # 42
# Разбиение кортежа полученного из функции
(quotient, modulo) = div_mod(13, 4)
```

