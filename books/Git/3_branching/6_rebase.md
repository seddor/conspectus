# Перебазирование

В git есть два способа внести изменения из одной ветки в другую: мердж, ребейз. 

## Простой ребейз

Суть ребейза, что ветки не мерджаться между собой по средством третьего коммита, а берёт измения из одного коммита и применяет поверх другого. 

```bash
git rebase <ranch_name>
```
>Это работает следующим образом: берется общий родительский снимок (snapshot) двух веток (той, в которой вы находитесь, и той, поверх которой вы выполняете перебазирование); берется дельта (diff) каждого коммита той ветки, на который вы находитесь, эти дельты сохраняются во временные файлы; текущая ветка устанавливается на тот же коммит, что и ветка, поверх которой вы выполняете перебазирование; и, наконец, ранее сохраненные дельты применяются поочереди.
>Учтите, что снимок, на который ссылается ваш последний коммит — является ли он последним коммитом после перебазирования или коммитом слияния после слияния — в обоих случаях это один и тот же снимок, отличаются только истории коммитов. Перебазирование повторяет изменения из одной ветки поверх другой в порядке, в котором эти изменения были представлены, в то время как слияние берет две конечные точки и сливает их вместе.

## Более сложный ребейз

```bash
git rebase --onto <target_branch> <origin_branch> <change_branch>
```
Git возьмёт изменя из `<change_branch>`, который нет в `<origin_branch>` и повторит их на `<target_branch>`. 
После этого достаточно переключится на `<target_branch>` и сделать `git merge <change_branch>`, при этом произойдет простой мердж перемотной, без лишних мердж-коммитов.

```bash
git rebase <base_branch> <topic_branch>
```
Применяет измения из `<topic_branch>` к `<base_branch>`. 

## Опасности

>**Не перемещайте коммиты, уже отправленные в публичный репозиторий**

При ребейзе отменяются сущевствующие коммиты и создаются новые, **похожие** на старые, но не являющиеся ими. И если эти коммиты уже были запушены и спулены другими людьми, а после этого произошёл `rebase` то людям придётся заново выполнить мердж сущевствующих коммитов. 