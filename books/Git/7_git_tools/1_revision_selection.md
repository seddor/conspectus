# Выбор ревизии

Git позволяет указать коммиты или их диапозон различными способами:

## Одиночные ревизии

Способы для обращения к одному коммиту(помимо использование полного хеша коммита)

```bash
git show <commit>
```
Показывает коммит

### Сокращёный SHA-1

Если передать Git не полный хеш, то он будет интерпретировать данную часть, и если есть коммит, хеш которого начинается так-же, и этот коммит только один, то git автоматически определит, что имеется в виду именно этот коммит.

Git может сам вычислить уникальные сокращения для коммитов:
```bash
git log --abbrev-commit
```
В логах будут использоваться уникальные сокращёные хеши.

### Ссылки на ветки

Для просмотра последнего коммита в ветке можно использовать имя ветки весто хеша
```bash
git show <branch>
```
Покажет последний коммит на ветке `<branch>`

>Если вы хотите узнать SHA-1 объекта, на который указывает ветка, или увидеть к чему сводятся все примеры в терминах SHA-1, то вы можете воспользоваться служебной командой Git, называемой rev-parse. Вы можете прочитать Git изнутри для получения дополнительной информации о служебных командах; в общем, команда rev-parse существует для низкоуровневых операций и не предназначена для ежедневного использования.

### RefLog-сокращения

Git в фоне введёт журнал ссылок — в нём записывается куда указывал HEAD за помследние несколько месяцев.

```bash
git reflog
```
Покажет журнал ссылок.

Пример вывода:
```
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by recursive.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
```

Для указания коммита можно использовать сслыку видал `@{n}`
```bash
git show HEAD@{5}
```
Можно так:
```
git show master@{yesterday}
```
Ссылки можно также смотреть в `git log`:
```bash
git log -g
```
**Вся информация в жрурнале ссылок локальна**

### Ссылка на предоков

#### `^`

Если поместить `^` в конец ссылки то git будет отображаться к предку коммита.
Посмотреть предыдущий коммит:
```bash
git show HEAD^
```
Если указать число после `^`, например `^2` то это будет обозначать второй родитель коммита, такой синтаксис будет полезен только для мердж-коммитов, т.к. они имеют больше одного родителя. Первым родителям будет ветка в которые выполняли слияние, а вторым — коммит в ветке которую сливали. 
Так-же можно: `HEAD^^`

#### `~`

`~` тоже ссылкается на предков коммит. Работа похоже на `^`, т.е. `HEAD~` === `HEAD^`. Разница проявляется при указании числа, `HEAD~2` обозначает `первый родитель первого родителя`.

Эти обозначения мжно комбинировать вместе:
```
HEAD~3^2
```
Второй родитель третьего первого родителя.

## Диапозоны коммитов

### Две точки

Git будет включать в диапозон то, что достижимо из одной точки, но не достижимо из другой.
```bash
git log master..dev
```
Покажет лог для коммитов, которые есть в `dev`, но нет в `master`.

Так-же можно посмотреть, например, что будет запушено:
```bash
git log origin/master..HEAD
```

### Множество точек

Чтобы узнать какие коммиты присутвуют в любой из нескольких веток, но отсутвуют в текущей:
```bash
git log ^refA..refB
git log refB --not refA
```
всё это эквивалентно этому:
```bash
git log refA..refB
```
Например, нужно увидеть все коммиты из `refA`, `refB`, не доступные в `refC`:
```bash
git log refA refB ^refC
git log refA refB --not refC
```

### Три точки

Используется когда нужно посмотреть все коммиты, доступные хотя-бы из одной ссылки, но не в обеих сразу.
```bash
git log master...dev
```
* `--left-right` — отображет сторону диапозона в которой был сделан коммит.
