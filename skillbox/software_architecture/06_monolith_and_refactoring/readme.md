# Интеграция

## Проектирование монолита. Первые предпосылки перехода к микросервисам

### Что же лучше?

* Монолит
* Микросервисы
* Любой тип распределённой архитектуры

Нет правильного ответа на вопрос что лучше, правильней отвечать на вопрос "когда?".

Любая архитектура лучше тогда, когда она соответствует требованиям бизнеса.

Стоит учитывать цену разработки и пооддержки.

### Как посчитать цену монолита?

* Поддержка текущего решения
* Время на разработку нового функционала
* Добавочное время к тестированию, если монолит разрастается
* Сложность работы над ним нескольких команд
* Сложность масштабирования
* Сложность оптимизаций
* Сложность отказа от монолита

### Как посчитать цену микросервисов?

* Поддержка инфраструктуры
* Работа с распределёнными транзакциями
* Сложность логирования
* Сложность мониторинга
* Сложность версионирования и соблюдения контрактов
* Интеграции между микросервисами
* PipeLine по установке новых версий

### Выбор

После всех оценок цен, нужно решить стоит ли переходить на микросервисы в данный момент, или остаться на монолите будет дешевле?

### Уменьшение стоимости ухода от монолита

1. Необходмо разделять весь монолит на слои:
  * Presenation layer — представление, содержит API
  * Business layer — бизнес, содержит бизнес-сущности и бизнес-логику, здесь происходит основная работа с данными
  * Persistance layer — слой абстракции БД
  * Database layer — слой БД
2. Монолит необходимо делать модульным
3. Модули должны связываться между собой только на уровне бизнес-логики, чтобы разделять их было проще.

Для преобразования модулей в сервисы необходимо всю логики с уровня бизнес-логики перенести на уровень представления.

### Когда стоит делить монолит?

* Необходимо увеличить скорость разработки
* Увеличилось число команд
* Сложная и долгая процедура тестирования
* Появляются отдельные высоконагруженные модули
* Дорого покупать более мощное железо
* Вся логика приложения не помещается в голове одного
разработчика

#### Процесс разработки

Делится на 4 этапа:
* Проектирование
* Разработка
* Тестирование
* Релиз

##### Проектирование

* Увеличилось количество документации
* Сложные взаимосвязи
* Много связей с одним модулем

##### Разработка

* Начал появляться дублирующий функционал
* Большее число конфликтов при работе с версионированием

##### Тестирование

* Увеличилось время тестирования
* Увеличилось время на покрытие тестами
* Усложнились тесты
* Надо проверять действия на соседние модули

##### Релиз

* Время релиза увеличилось
* Увеличилась сложность проверок после релиза
* Вас больше не устраивает время простоя во время релиза

##### Сопровождение

* Нагрузка на один модуль отражается на других
* Более мощных серверов или не существует или они очень
дорогие
* Необходимость быстро и гибко масштабироваться

### Итоги

* Гачинать почти всегда лучше с монолита
* Хорошо спроектированный монолит ― лёгкость перехода
на микросервисы

## Подходы к разделению монолита 

### Вынос UI части

#### Предпосылки

* Интенсивная разработка UI
* Желание разделить релизы
* Уход от MVC frameworks
* Отдельная команда front-разработки

#### Отделение UI

Чаще всего для разделения поднимается отдельный сервер на NodeJS для UI. Монолит будет отвечать за отдачу данных. Разруливать запросы между сервисами будут на уровне ngnix.

### Новая бизнес-логика как новый сервис

#### Предпосылки

* Мы уже поняли, что идём к микросервисам
* Сложная логика
* Высокая нагрузка
* Отдельная команда

### Выделение текущей логики как сервис

#### Предпосылки

Понять стоит ли выносить модуль в отдельный сервис можно по следующим признакам:

* Большое число изменений
* Желание чаще релизить
* Желание упростить релизы
* Сделать независимым при отказах монолита
* Независимость от других модулей и готовность к выносу

#### Реализация

* Реализовать сервис
* Предусмотреть быстрый откат — чтобы можно было быстро переключиться на старую версию в случае проблем, если модуль критичен то можно реализовать постепенное переключение модуля, чтобы какой-то процент пользователь использовал новый модуль и другие старый и так постапенно пускать всё больше пользователей.

Для реализации необходимо:
* Выделить все связи модуля с монолитом
* Перенести логику в новый сервис
* Проработать интеграцию монолита и сервиса

#### Мониторинг

Перед выкатыванием сервиса в продакшен нужно проработать вопросы монтиринга и логирования:
* Определили метрики успешности
* Определили процессы, которые могут быть задеты
* Доработали сбор метрик для онлайн-мониторинга
* Доработали логирование

#### Релиз

##### Шаг 1

* Выкатили новый сервис
* До сих пор работаем с внутренним модулем
* Ведём наблюдения

##### Шаг 2

* Переключаем трафик на новый сервис
* Ведём наблюдения

##### Шаг 3

* Ведём наблюдения

##### Шаг 4.1

Если возникли проблемы

* Появление ошибок
* Переключаем всё на внутренний модуль

##### 4.2 шаг

Если всё ок

* Внедрение прошло успешно
* Запрещаем пользоваться модулем
* Ждём несколько релизов монолита
* Удаляем модуль*

## Рефакторинг БД

Сложности при переходе:
* Логика походов в репозитории разных модулей
* Логика, хранящиеся в БД
* Неупорядоченные связи между слоями

### Связи между слоями

Для упрощения перехода на микросервисы все связи между слоями должны идти сверху вниз, нежестоящий слой не должен обращаться к вышестоящему. Допускаются связи между объектами одного слоя.

### Связи между модулями

Связи между модулями должны происходить посредством слоя представления. Связи между другими уровнями между модулями недопустимы.

### Логика в БД

Плюсы:
* Не надо пересылать много данных по сети
* Нет сетевых задержек
* Логика ближе к данным, с которыми аботает (локальное ускорение работы)

Минусы:
* Отсутствия unit-тестов
* Сложный рефакторинг, IDE не подсвечивает зависимости
* Логирование, обработка ошибок
* Сбор метрик
* Отсутствие менеджера зависимостей
* Версионирование 
* Специфичность самого языка
* Отсутствие фреймворков
* Сложность замены СУБД
* Отладка
* Масштабирование

### Вынос связей из БД

Для вынесение связи необходимо вынести эту связи из уровня БД на уровень бизнес-логики.

По позвожности нужно обращаться к сущностям других сервисов не по ИД, а по параметрам бизнес логики.

### Методы HTTP и REST

* GET ― получить ресурс
* POST ― создание, сложные запросы
* PUT ― полная замена
* PATCH ― частичное обновление
* DELETE ― удаление

## Интеграция с монолитом

### Внешние сервисы

У монолита может быть множество севисов, которые ходят к нему за информацией. Если монолит реализован так, что выносить из него модули в микросервисы достаточно легко и все связи перенесли в микросервис, то перключить какого-либо потребителя на микросервис легко. Потому что данные между монолитом и микросервисом будут синхронизироваться за счёт организованных связей.

Однако, обычно так не сделано. Тогда обычно создают рядом ещё один микросервис, который полностью дублирует функционал модуля, который необходимо вынести и после этого только задумываются и синхронизации. Для этого создают модуль который помещается в микросервис и отвечает за интеграцию со старой БД, его ещё называют "предохранительный слой", он нужен чтобы логика старой БД не просачивалась в новый микросервис, но при этом отвечает за сихнронизацию со старой БД. Сам модуль должен легко отключаться, чтобы его можно было легко выпилить после полного отказа от монолита.

Для реализацию согласованности нужно открыть транзакцию в момент записи в первую БД и закрыть её после успешной записи в обе БД.

#### Изменение API

##### Фасад

* Скрывает сложную логику
* Определяет одну точку взаимодействия

**Важно: Возможно попадание бизнес-логики из сервисов.**

Фасад ставится перед старым монолитом, он будет имитировать старый API, при этом будет использовать новый API. Если не все нужные возможности монолита перенесены в микросервисы, то фасад может использовать нужные API монолита, постепенно переходя на новое API.

## Итоги

### Первый этап

Для наиболее легко перехода на микросервисы нужно правильно проектировать монолит. Для этого важно использовать:
* Выделение слоёв
* Деление на модули

### Отказ от монолита

Прежде чем переходить нужно оценить цену отказа от монолита:

Монолит:
* Стоимость поддержки монолита
* Стоимость развития монолита

Микросервисы:
* Стоимость отказа от монолита
* Стоимость поддержки микросервисов и инфраструктуры
* Стоимость развития микросервисов

### Legacy-монолит

Если небоходимо ещё использовать монолит, то можно реализовать фасад, который будет перенаправлять старые вызовы к API монолита на новые API микросервисов.

### Интеграция через БД

* В случае, если нет возможности дорабатывать монолит
* Если legacy-монолит работает по логике, непонятной вам
* Время рефакторинга очень велико

Тогда нужно:
* Провести анализ работы монолита и БД
* Понять, не ломаете ли вы логику
* Всё ли учли при работе с БД из другого сервиса

Для согласованности данных нужно создать подмодуль в микросервисе, которые будет отвечать за интеграцию с БД монолита. При записи данные через микросервис нужно создавать транзакцию которая будет заверщаться после успешной записи в **обе** БД.

### Мониторинг

Важно реализовать монтиоринг:
* Критерии успешности внедрения
* Метрики для отслеживания состояния
* Работа с потребителями монолита
* Обязательная возможность отката
* Заранее определённые критерии отката
* Выбор времени с наименьшей нагрузкой
